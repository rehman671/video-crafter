{% load static %}
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{% static 'styles/style.css' %}">
    <link rel="stylesheet" href="{% static 'styles/music.css' %}">
    <link rel="stylesheet" href="{% static 'styles/fonts.css' %}">
    <link rel="stylesheet" href="{% static 'styles/main.css' %}">
    <link rel="stylesheet" href="{% static 'styles/add-scene-style.css' %}">
    <link rel="stylesheet" href="{% static 'styles/main-scenes.css' %}">
    <link rel="stylesheet" href="{% static 'styles/scene.css' %}">
    <link rel="stylesheet" href="{% static 'styles/scene-style.css' %}">
    <link href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" rel="stylesheet" />
    <link rel="icon" href="{% static 'images/iconlogo.svg' %}">
    <title>VideoCrafter.io</title>
    <style>
/* Enhanced Template Download Button */
.template-download-wrapper {
    margin: 15px 0;
}

.template-download-btn {
    display: inline-flex;
    align-items: center;
    padding: 12px 20px;
    background: linear-gradient(135deg, #f8f9ff 0%, #e8f0fe 100%);
    border: 2px solid #d1d9ff;
    border-radius: 10px;
    text-decoration: none;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(134, 74, 249, 0.1);
    min-width: 280px;
    max-width: 100%;
}

.template-download-btn:hover {
    background: linear-gradient(135deg, #864AF9 0%, #bfa9fc 100%);
    border-color: #864AF9;
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(134, 74, 249, 0.3);
}

.template-btn-content {
    display: flex;
    align-items: center;
    gap: 12px;
    width: 100%;
}

.template-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    background: rgba(134, 74, 249, 0.1);
    border-radius: 8px;
    color: #864AF9;
    transition: all 0.3s ease;
    flex-shrink: 0;
}

.template-download-btn:hover .template-icon {
    background: rgba(255, 255, 255, 0.2);
    color: white;
}

.template-btn-text {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 2px;
}

.template-title {
    font-weight: 600;
    font-size: 14px;
    color: #374151;
    transition: color 0.3s ease;
}

.template-subtitle {
    font-size: 12px;
    color: #6b7280;
    transition: color 0.3s ease;
}

.template-download-btn:hover .template-title,
.template-download-btn:hover .template-subtitle {
    color: white;
}

/* Responsive design for smaller screens */
@media (max-width: 768px) {
    .template-download-btn {
        min-width: 100%;
        justify-content: center;
    }
    
    .template-btn-content {
        justify-content: center;
    }
}
        .upload-container.drag-over {
    background-color: #f3f0ff;
    border-color: #864AF9;
}

.upload-input {
    display: none;
}

#clear-file {
    display: none;
    cursor: pointer;
    position: absolute;
    top: 15px;
    right: 5px;
    color: red;
    font-size: 20px;
}
.popup-container{
    max-width: 635px;
}
        
        /* Free user overlay styling */
#freeUserOverlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(200, 200, 200, 0.8);
    z-index: 10;
    display: flex;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(2px);
}

#freeUserOverlay div {
    background-color: white;
    padding: 20px;
    border-radius: 8px;
    max-width: 80%;
    text-align: center;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

#freeUserOverlay h3 {
    color: #864AF9;
    margin-top: 0;
    margin-bottom: 10px;
}

#freeUserOverlay p {
    margin-bottom: 15px;
}

.upgrade-button {
    background-color: #864AF9;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    text-decoration: none;
    display: inline-block;
    transition: background-color 0.3s;
}

.upgrade-button:hover {
    background-color: #7038e0;
}
    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        75% { transform: translateX(5px); }
    }

        /* Draft Save Button and Modal Styling */
        .save-draft-btn{
    display: inline-block;
    padding: 10.5px 20px;
    color: #6c25be;
    text-align: center;
    text-decoration: none;
    border-radius: 10px;
    font-size: 15px;
    border: 2px solid;
    font-weight: 500;
    margin: 0px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    position: relative;
    left: -26px;
    top: 0;
    background-color: #f9f9f9;
}

        .save-draft-btn:hover {
            background-color: #f9f9f9;
        }

        .draft-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .draft-modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            min-width: 300px;
            text-align: center;
        }

        .draft-modal-content h3 {
            color: #864AF9;
            margin-top: 0;
            margin-bottom: 20px;
        }

        .draft-modal-content input {
            width: 100%;
            padding: 10px;
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .draft-modal-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .draft-save-btn, .draft-cancel-btn {
            padding: 8px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Arial', sans-serif;

        }

        .draft-save-btn {
            background-color: #864AF9;
            color: white;
        }

        .draft-save-btn:hover {
            background-color: #7038e0;
        }

        .draft-cancel-btn {
            background-color: #e0e0e0;
            color: #333;
        }

        .draft-cancel-btn:hover {
            background-color: #d0d0d0;
        }
        .progress-fill{
            width: 38% !important;
        }
        .sub-div3{
            background-color: #9662f9 !important;
        }
        .script-tabs {
    display: flex;
    margin-bottom: 20px;
    border-bottom: 2px solid #f0f0f0;
    border-radius: 8px 8px 0 0;
    overflow: hidden;
    background-color: #fafafa;
}

.tab-button {
    flex: 1;
    padding: 16px 20px;
    background: #fafafa;
    border: none;
    border-bottom: 3px solid transparent;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.3s ease;
    color: #666;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
}

.tab-button.active {
    color: #864AF9;
    background-color: white;
    border-bottom-color: #864AF9;
    font-weight: 600;
}

.tab-button:hover:not(.active) {
    background-color: #f0f0f0;
    color: #555;
}

.tab-content {
    display: none;
    animation: fadeIn 0.3s ease-in;
}

.tab-content.active {
    display: block;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* History Dropdown Styles */
.history-dropdown-container {
    margin: 20px 0;
}

.history-select {
    width: 100%;
    padding: 14px 16px;
    border: 2px solid #e0e0e0;
    border-radius: 8px;
    font-size: 14px;
    background-color: white;
    margin-top: 15px;
    transition: all 0.3s ease;
    font-family: inherit;
}

.history-select:focus {
    outline: none;
    border-color: #864AF9;
    box-shadow: 0 0 0 3px rgba(134, 74, 249, 0.1);
}

.history-select:hover {
    border-color: #ccc;
}

.history-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 30px 20px;
    color: #666;
    background-color: #f8f9fa;
    border-radius: 8px;
    margin-top: 15px;
}

.loading-spinner {
    width: 20px;
    height: 20px;
    border: 2px solid #f3f3f3;
    border-top: 2px solid #864AF9;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-right: 12px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.history-error {
    text-align: center;
    padding: 25px 20px;
    background-color: #fff5f5;
    border: 1px solid #fed7d7;
    border-radius: 8px;
    margin-top: 15px;
}

.error-text {
    color: #e53e3e;
    display: block;
    margin-bottom: 15px;
    font-weight: 500;
}

.retry-button {
    background-color: #864AF9;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: background-color 0.3s ease;
}

.retry-button:hover {
    background-color: #7038e0;
}

/* History Preview Styles */
.history-preview {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border: 1px solid #e0e0e0;
    border-radius: 12px;
    padding: 20px;
    margin-top: 20px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.preview-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 15px;
    font-size: 14px;
}

.voice-name {
    background: linear-gradient(135deg, #864AF9 0%, #9c7afc 100%);
    color: white;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

.preview-text {
    background-color: white;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 16px;
    max-height: 140px;
    overflow-y: auto;
    margin-bottom: 15px;
    font-size: 14px;
    line-height: 1.5;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
    word-wrap: break-word;
    overflow-wrap: break-word;
    white-space: pre-wrap;
}

.history-preview {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border: 1px solid #e0e0e0;
    border-radius: 12px;
    padding: 20px;
    margin-top: 20px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    max-width: 100%;
    overflow: hidden;
}
.preview-details {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 15px;
    font-size: 12px;
    color: #666;
}

.preview-details > span {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 8px;
    background-color: white;
    border-radius: 6px;
    border: 1px solid #e9ecef;
}

.character-count::before {
    content: "📝";
    margin-bottom: 4px;
}

.date::before {
    content: "📅";
    margin-bottom: 4px;
}

.subtitle-count::before {
    content: "🔢";
    margin-bottom: 4px;
}

.preview-details .character-count {
    font-weight: 600;
    color: #495057;
}

.preview-details .date {
    font-style: italic;
    color: #6c757d;
}

.preview-details .subtitle-count {
    font-weight: 600;
    color: #864AF9;
}

/* Responsive Design */
@media (max-width: 768px) {
    .tab-button {
        padding: 12px 16px;
        font-size: 13px;
    }
    
    .tab-button img {
        width: 14px !important;
        height: 14px !important;
        margin-right: 6px !important;
    }
    
    .preview-details {
        grid-template-columns: 1fr;
        gap: 10px;
    }
    
    .history-preview {
        padding: 15px;
    }
}

/* Enhanced file button styles for history */
#historyLoadButton:disabled {
    background-color: #e9ecef;
    color: #6c757d;
    cursor: not-allowed;
    opacity: 0.6;
}

#historyLoadButton:not(:disabled) {
    /* background: linear-gradient(135deg, #864AF9 0%, #9c7afc 100%); */
    transform: translateY(0);
    transition: all 0.3s ease;
}

#historyLoadButton:not(:disabled):hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(134, 74, 249, 0.3);
}

/* Enhanced preview styles for splitting functionality */
.preview-text-container {
    margin-bottom: 15px;
}

.preview-text {
    background-color: white;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 16px;
    max-height: 5000px;
    overflow-y: auto;
    font-size: 14px;
    line-height: 1.5;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
    word-wrap: break-word;
    overflow-wrap: break-word;
    white-space: pre-wrap;
    cursor: text;
    position: relative;
}

.preview-text.splitting-mode {
    background-color: #f8f9ff;
    border-color: #864AF9;
    cursor: crosshair;
}

.preview-instructions {
    margin-top: 8px;
    padding: 8px;
    background-color: #f0f4ff;
    border: 1px solid #d1d9ff;
    border-radius: 4px;
    font-size: 12px;
    color: #4a5568;
    text-align: center;
}

.subtitle-segment {
    display: inline-block;
    padding: 2px 4px;
    margin: 1px;
    border-radius: 3px;
    border: 1px solid transparent;
    transition: all 0.2s ease;
}

.subtitle-segment:hover {
    background-color: #e8f0fe;
    border-color: #864AF9;
}

.subtitle-segment.exceeds-limit {
    background-color: #fff5f5;
    border-color: #feb2b2;
    color: #c53030;
}

.subtitle-segment.exceeds-limit:hover {
    background-color: #fed7d7;
}

.split-point {
    display: inline-block;
    width: 2px;
    height: 1.2em;
    background-color: #864AF9;
    margin: 0 1px;
    vertical-align: middle;
    animation: blink 1s infinite;
}

@keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
}

.subtitle-count-info {
    font-size: 11px;
    color: #666;
    margin-top: 4px;
}

.subtitle-count-warning {
    color: #e53e3e;
    font-weight: bold;
}
div{
    user-select: none;
}
mark{
    user-select: none;
}

    </style>
</head>
<body>
    <header class="header">
        <div class="main-div">
            <div class="sub-main-div">
                <img src="{% static 'images/logo.svg' %}" alt="Logo">
                <a href="{% url 'preview' %}" class="anchor-sub-main"></a>
            </div>
            <div class="right">
                <span class="right-span">Credits Remaining: <span id="number">{{ user_subscription.unused_credits }}</span></span>
                <div class="line"></div>
                <div class="img" id="pfp" onclick="toggleDropdown()">
                    <div class="img-sub-div">
                        <div class="img-sub">
                            <img src="{% static 'images/profile.svg' %}" alt="Profile">
                        </div>
                    </div>
                </div>

                <div id="pfpdropdown" class="not-present" style="z-index:999;">
                    <div class="not-present-sub">
                        <span class="not-present-sub-span1">{{ user_subscription.user.first_name }}</span>
                        <span class="not-present-sub-span2">{{ user_subscription.user.email }}</span>
                    </div>
                    <div class="profile-main-div">
                        <div class="profile-sub-div">
                            <div class="dropdownText">
                                <span class="dropdownText" style="width: fit-content;">Credit Left</span>
                                <span class="dropdownText" style="width: fit-content; color: #19191980;">{{ user_subscription.unused_credits }}</span>
                            </div>
                        </div>
                        <span class="dropdownText">
                            <a href="{% url 'asset_library' %}">Manage Asset Library</a>
                        </span>
                        <span class="dropdownText">
                            <a href="{% url 'recent_videos' %}">Manage Video Drafts</a>
                        </span>
                        <span class="dropdownText">
                            <a href="{% url 'manage_subscription' %}">Manage Subscription</a>
                        </span>
                        <span class="dropdownText">
                            <a href="{% url 'speed_up_video' %}">Video Speed Up</a>
                        </span>
                    </div>
                    <div class="profile-last-div">
                        <span class="dropdownText"><a href="{% url 'logout' %}">Log Out</a></span>
                    </div>
                </div>
            </div>
        </div>
        <!-- Draft Save Button -->
    </header>

    <!-- Draft Name Popup Modal -->
    <div id="draftModal" class="draft-modal">
        <div class="draft-modal-content">
            <h3>Save as Draft</h3>
            <input type="text" id="draftName" placeholder="Enter draft name" maxlength="25">
            <div class="draft-modal-buttons">
                <button id="saveDraftConfirm" class="draft-save-btn">Save</button>
                <button id="cancelDraft" class="draft-cancel-btn">Cancel</button>
            </div>
        </div>
    </div>

    <div class="progressbar">
        <div class="sub-div">
            <div class="progress-fill" style="width:66.66666666666667%"></div>
            <div class="sub-div2 completed"></div>
            <div class="sub-div3 completed"></div>
            <div class="sub-div4 active"></div>
            <div class="sub-div5 "></div>
            <div class="voice-subtitle ">Voice & Subtitle Design</div>
            <div class="sceneselection ">Scene Selection</div>
            <div class="bgmselection active-text">Background Music Selection</div>
            <div class="download ">Download</div>
        </div>
    </div>
    <div class="body-container">
        <div id="pfp"></div>
        <div id="pfpdropdown" class="not-present"></div>
     <div class="card-container">
            <div class="card" style="max-height: 15000px;">
                <div class="card-header">
                     <div id="previousButton">
                        <a href="{% url 'preview' %}">
                            <img src="{% static 'images/back.svg' %}" alt="Back">
                        </a>
                    </div>
                    <span class="card-header-span">Select Your Script</span>
                </div>
                <div class="card-body">
                    <!-- Tab Navigation -->
                    <div class="script-tabs">
                        <button class="tab-button active" id="history-tab" onclick="showTab('history')">
                            <img src="{% static 'images/iconlogo.svg' %}" alt="" style="width: 16px; height: 16px; margin-right: 8px;">
                            ElevenLabs Voiceovers
                        </button>
                    </div>

                    <!-- Upload Tab Content -->
                    <!-- <div id="upload-content" class="tab-content">
                        <div class="Script-text-file-text">
                            <div class="Script-text-file-text-sub">
                                <div class="script-text">Script Text File:</div>
                                <div class="vh-parent">
                                    <div class="vh-child">
                                        <span class="text3">Please Make Sure Your Script Is On Txt File</span>
                                        <span class="text3" style="display: block; color: #FF5050; margin-top: 5px;">Each line should be no more than {{ MAX_SUBTITLE_LENGTH|default:100 }} characters</span>
                                    </div>
                                </div>
                            </div>
                            <a href="{% static 'dummy/template.txt' %}" download="" class="download-btn">
                                Click Here To Download An Empty Template
                            </a>
                        </div>
                        <form method="post" enctype="multipart/form-data" id="file-upload-form">    
                            {% csrf_token %}
                            <div class="Script-text-file-Upload">
                                <div class="script-upload-sub">
                                    <img src="{% static 'images/choose-icon.svg' %}" alt="Choose file">
                                    <span class="text2 choosefile-heading">Choose file</span>
                                    <input required="" type="file" id="fileUpload" accept=".txt" name="videotextfile">
                                </div>
                                <div class="text2" id="fileName" style="color:#00000080">No file chosen</div>
                            </div>
                            <div class="center-container">
                                <button type="submit" id="scriptUploadButton" class="file-button">
                                    Load Script
                                </button>
                            </div>
                        </form>
                    </div> -->

                    <!-- History Tab Content -->
                   <div id="history-content" class="tab-content active">
    <div class="Script-text-file-text">
        <div class="Script-text-file-text-sub">
            <div class="script-text">ElevenLabs Voiceover:</div>
                <div class="vh-child">
                    <span class="text3">Select from your previous ElevenLabs voiceovers</span>
                    <span class="text3" style="display: block; color: #864AF9; margin-top: 5px;">Text will be automatically split into subtitles</span>
                </div>
               
        </div>


    <div class="vh-child" style="margin-bottom: 15px;">
        <span class="text3" style="font-size: 14px; color: #6b7280; line-height: 1.5;">Upload a .txt file with identical content, split into lines for custom subtitle segments</span>
    </div>
    <!-- Removed -->
    <div class="file-upload-wrapper" style="position: relative;display: none;">
        <div class="custom-file-input" onclick="document.getElementById('historySplitFile').click()" style="
            display: flex; 
            align-items: center; 
            padding: 16px 20px; 
            background: white; 
            border: 2px dashed #d1d9ff; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: all 0.3s ease;
            min-height: 60px;
        " onmouseover="this.style.borderColor='#864AF9'; this.style.backgroundColor='#fefeff';" onmouseout="this.style.borderColor='#d1d9ff'; this.style.backgroundColor='white';">
            <div class="upload-icon" style="width: 40px; height: 40px; background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%); border-radius: 8px; display: flex; align-items: center; justify-content: center; margin-right: 16px;">
                <img src="{% static 'images/choose-icon.svg' %}" alt="Upload" style="width: 20px; height: 20px; opacity: 0.8;">
            </div>
            <div class="upload-text-content" style="flex: 1;">
                <div class="upload-title" style="font-weight: 600; color: #374151; font-size: 15px; margin-bottom: 4px;">Choose Split File</div>
                <div class="upload-subtitle" style="font-size: 13px; color: #6b7280;">Click to browse or drag & drop your .txt file</div>
            </div>
            
            <div class="upload-arrow" style="color: #864AF9; font-size: 18px; margin-left: 12px;">→</div>
        </div>
        <div class="template-download-wrapper" style="margin-top: 15px; text-align: center;">
         <a href="{% static 'dummy/template.txt' %}" download="" class="" style="color:#6c25be;text-decoration: none;">
 Download Empty txt Template Here
 </a>

        <!-- <span class="template-title">Download Empty txt Template Here</span> -->
        <!-- <span class="template-subtitle">Download Empty txt Template Here</span> -->
        <!-- <div class="template-btn-content">
            <div class="template-icon">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7,10 12,15 17,10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
            </div>
            <div class="template-btn-text">
            </div>
        </div> -->
</div>
        <input type="file" id="historySplitFile" accept=".txt" style="display: none;">
        
        <div class="file-status" id="splitFileStatus" style="margin-top: 12px; padding: 12px; border-radius: 8px; display: none;">
            <div class="status-content" style="display: flex; align-items: center;">
                <div class="status-icon" id="statusIcon" style="width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 12px; font-size: 12px; font-weight: bold;"></div>
                <div class="status-text">
                    <div class="status-title" id="statusTitle" style="font-weight: 600; font-size: 14px; margin-bottom: 2px;"></div>
                    <div class="status-subtitle" id="statusSubtitle" style="font-size: 12px; opacity: 0.8;"></div>
                </div>
            </div>
    </div>
</div>
    </div>
                        
                        <div class="history-dropdown-container">
                            <!-- <div class="script-upload-sub">
                                <img src="{% static 'images/iconlogo.svg' %}" alt="Select history">
                                <span class="text2 choosefile-heading">Select Voiceover History</span>
                            </div> -->
                            
                            <!-- Loading State -->
                            <div id="history-loading" class="history-loading" style="display: none;">
                                <div class="loading-spinner"></div>
                                <span>Loading voiceovers ...</span>
                            </div>
                            
                            <!-- Error State -->
                            <div id="history-error" class="history-error" style="display: none;">
                                <span class="error-text">Failed to load voiceovers. Please try again.</span>
                                <button onclick="loadVoiceoverHistory()" class="retry-button">Retry</button>
                            </div>
                            
                            <!-- Dropdown -->
                            <select id="voiceover-history-select" class="history-select" style="display: none;">
                                <option value="">Select a voiceover...</option>
                            </select>
                            
                            <!-- Selected History Preview -->
<div id="selected-history-preview" class="history-preview" style="display: none;">
    <div class="preview-header">
        <strong>Selected Voiceover:</strong>
        <span class="voice-name" id="preview-voice-name"></span>
    </div>
    <div class="preview-text-container">
        <div class="preview-text" id="preview-text" contenteditable="false"></div>
        <div class="preview-controls">
          <div class="preview-instructions" style="user-select: none;">
<small>💡 <strong>Ctrl+Click (⌘+Click on Mac)</strong> to split at word boundaries (max 100 chars per segment) • <strong>Double-click</strong> segment to merge with next • <strong>Shift+Click</strong> segment to merge with previous</small>

</div>
            <div class="preview-actions">
                <button type="button" class="preview-btn reset-btn" onclick="resetAllSplits()">
                    <i class="ri-refresh-line"></i> Reset All
                </button>
                <button type="button" class="preview-btn undo-btn" onclick="undoLastSplit()" id="undoSplitBtn" disabled>
                    <i class="ri-arrow-go-back-line"></i> Undo Last
                </button>
            </div>
        </div>
    </div>
    <div class="preview-details">
        <span class="character-count" id="preview-char-count"></span>
        <span class="date" id="preview-date"></span>
        <span class="subtitle-count" id="preview-subtitle-count"></span>
    </div>
</div>
                        </div>
                        
                        <div class="center-container">
                            <button type="button" id="historyLoadButton" class="file-button" disabled onclick="loadSelectedHistory()">
                                Load Selected Script
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Keep the second card as is -->
            <div class="card" id="uploadCard" style="position:relative">
                <div class="card-header">
       
                    <span class="card-header-span">Upload To Your Asset Folder</span>
                    <h5>These Files Will be Saved In Your Asset Library Which You Can Manage Through The Profile Icon
                        Above</h5>
                </div>
                <div class="card-body upload">
                    <div class="Script-text-file-text">
                        <div class="upload-folder-heading">
                            <div class="Script-text-file-text-sub">
                                <div class="script-text">Upload Folder:</div>
                               
                            </div>
                        </div>
                    </div>
                </div>
                <div class="Script-text-file-Upload">
                    <div class="script-upload-sub">
                        <img src="{% static 'images/choose-icon.svg' %}" alt="Choose file">
                        <span class="text2 choosefile-heading">Choose file</span>
                        <input id="fileInput" type="file" webkitdirectory="true" multiple="">
                    </div>
                    <div class="text2" id="fileName2" style="color:#00000080">No folder chosen</div>
                </div>
                <form id="uploadForm" enctype="multipart/form-data" method="POST" action="{% url 'asset_library' %}" style="display:none">
                    {% csrf_token %}
                    <input id="zipFile" type="file" name="zip_file" style="display: none;" accept=".zip">
                    <input type="text" id="directories" name="directories" hidden>
                    <div style="margin-top: 10px">
                        <div class="progressPercent">
                            <span id="progressPercent">0%</span>
                        </div>
                        <div class="progress-bar" style="width: 100%; height: 10px; background: #f0f0f0; border-radius: 5px;">
                            <div class="progress" id="progressBar" style="width: 0%; height: 100%; background: #9662f9; transition: width 0.3s ease;"></div>
                        </div>
                    </div>
                </form>
                <div id="centered-c" class="center-containered">
                    <div id="uploadStatus" style="text-align:center"></div>
                    <div id="progressWrapper" style="display:none">
                        <div id="progressBar"></div>
                        <div id="percent"></div>
                    </div><button class="file-button" id="videoUploadButton">Upload and Process</button>
                </div>
                {% if 'free' in user_subscription.plan.name %}
                <div id="freeUserOverlay">
                    <div>
                        <h3>Asset Upload Restricted</h3>
                        <p>This feature is only available for premium users. Upgrade your subscription to access asset uploads and other premium features.</p>
                        <a href="{% url 'manage_subscription' %}" class="upgrade-button">Upgrade Now</a>
                    </div>
                </div>
                {% endif %}
            </div>
        </div>
        <div>
            <div class="grid-container2">
                <div class="section">
                    <div class="section-header">Instructions <span>▶</span></div>
                    <div class="section-content" id="instructions">
                        <div class="bor" style="border:1px solid #cccccc"></div>
                      <h3>Step 1: Select Your ElevenLabs Voiceover</h3>
<p>Choose from your previously generated ElevenLabs voiceovers. The text will be automatically split into subtitle boxes. For example:</p>
<div class="highlight">
    <p>If your voiceover says, "Hello, my name is Steve," this will be automatically converted into
        subtitle boxes that you can then assign video clips to.</p>
</div>
<h3>Step 2: Highlight And Assign Clips</h3>
<p class="highlight-words">Highlight words:</p>
<p>Simply highlight the words in your script that you want to match with a video clip and assign
    a video clip.</p><a href="{% static 'public/videos/dummy.mp4' %}">Watch Video Tutorial</a>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">How To Upload Files To The Asset Folder<span>▶</span></div>
                    <div class="section-content" id="tips">
                        <div class="bor" style="border:1px solid #cccccc;margin-bottom:1rem"></div>
                        <div class="tips-background"
                            style="background-color:#f0f0f0;padding:4px 20px 20px 20px;line-height:162%">
                            <h3>Step 1</h3>
                            <p><strong>Create a main folder:</strong></p>
                            <p>On your computer, create one main folder (e.g., MyVideoAssets). This folder will contain
                                all your subfolders and video clips.</p>
                            <h4>Add Subfolders Inside The Main Folder:</h4>
                            <p>Within the main folder, create subfolders to categorize your videos. For example:</p>
                            <ul>
                                <li>Back Pain Clips</li>
                                <li>Fitness Clips</li>
                                <li>Testimonials</li>
                            </ul>
                            <h4>Add Video Files To Each Subfolder:</h4>
                            <p>Inside each subfolder, add the relevant video clips. For example:</p>
                            <ul class="ul-cl">
                                <li>Back Pain Clips<span style="color:#333"></span> <span class="vid">Clip1.mp4,
                                        Clip2.mp4</span></li>
                                <li>Fitness Clips<span style="color:#333"></span> <span class="vid">Workout1.mp4,
                                        Workout2.mp4</span></li>
                            </ul>
                            <h3>Step 2</h3>
                            <p><strong>Upload to VideoCrafter.io:</strong></p>
                            <ul>
                                <li>Go to the "Upload To Your Asset Folder" section.</li>
                                <li>Click "Choose File" and select the main folder (not individual subfolders).</li>
                                <li>Click "Upload And Process" to start the upload.</li>
                            </ul>
                        </div><a href="{% static 'public/videos/dummy.mp4' %}">Watch Video Tutorial</a>
                    </div>
                </div>
            </div>
        </div>
        <div class="lead-container lead-details" style="max-width:96%;margin:0 auto">
            <table id="leadsTable" class="lead-table" style="width:100%;display:table">
                <thead>
                    <tr style="height:fit-content">
                        <th class="slide-first" style="font-size:1.4rem">Subtitle</th>
                        <th style="font-size:1.4rem">Subtitle Text</th>
                        <!-- <th class="slide-last">Edit</th> -->
                        <th class="slide-last">Undo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr data-id="-1" style="height:5rem">
                        <td class="slide-first" style="font-size:1.4rem;position:relative;"
                            title="Drag to move">Slide 1</td>
                        <td id="highlightable_-1">
                            <div class="highlight-sub">
                                <!-- <textarea class="textarea-class" id="slide_text_-1" name="slide_text"
                                    placeholder="Type Your Script Here">
                                </textarea> -->
                                <div id="error-message_-1" class="error-message" style="display:none"></div>
                                <div class="error-message" style="display:none">Highlighting Must Start From The First
                                    Unassigned Word Of The Sentence.</div>
                            </div>
                        </td>
                        <!-- <td class="slide-last active"><a href="#" class="above-del"><i id="icon"
                                    class="ri-edit-box-line fa-sync-alt icon"
                                    style="margin:0 auto;font-size:20px;font-weight:600;cursor:pointer;vertical-align:middle"></i></a>
                        </td> -->
                        <td class="slide-last active">
                            <a href="#" class="above-del">
                                <img src="{% static 'images/undo.svg' %}" alt="Undo" style="width:1.2rem;height:3rem;cursor:pointer">
                            </a>
                        </td>
       
                    </tr>
                </tbody>
            </table>
            <div class="add-new-sub" style="display: none;">
                <div class="d-flex justify-content-start">
                    <a href="#" id="createLeadBtn" class="btn proceed-btn">Add New
                        Subtitle +
                    </a>
                </div>
                <div id="subtitle-limit-error" style="color: red; margin-top: 10px; display: none; font-size: 11px;">
                    Free plan users are limited to 10 subtitles. Please upgrade your subscription for unlimited subtitles.
                </div>
            </div>
            <input type="number" id="no_of_slides" hidden="" readonly="" name="no_of_slides" value="1">
            <div class="button-container">
                <button id="saveDraftBtn" class="save-draft-btn">Save Draft</button>

                <a href="" class="button-container-btn ">
                    <span id="button-text">Proceed To Background Music Selection</span>
                    <img id="proceed-svg" src="{% static 'images/arrow.svg' %}" alt="Arrow" style="display:inline-block">
                </a>
            </div>
        </div>
    </div>

    <!-- Hidden Modal for Asset Upload -->
    <div id="assetUploadModal" class="modal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
        <div class="modal-content" style="background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 500px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);">
            <form id="uploadForm" enctype="multipart/form-data" method="POST" action="{% url 'asset_library' %}">
                {% csrf_token %}
                <div class="modal-text">
                    <h2>Upload Folder</h2>
                    <p>Please Make Sure Your Folder Contains Video Clips</p>
                </div>
                <input id="fileInput" class="fileUpload" type="file" name="folder" webkitdirectory multiple>
                <input id="zipFile" type="file" name="zip_file" style="display: none;" accept=".zip">
                <div>
                    <div class="progressPercent">
                        <span id="progressPercent">0%</span>
                    </div>
                    <div class="progress-bar"
                        style="width: 100%; height: 10px; background: #f0f0f0; border-radius: 5px;">
                        <div class="progress" id="progressBar"
                            style="width: 0%; height: 100%; background: #9662f9; transition: width 0.3s ease;">
                        </div>
                    </div>
                </div>
                <div class="modal-buttons">
                    <button type="button" class="cancel-btn" onclick="closeAssetModal()">Cancel</button>
                    <button type="submit" class="upload-btn">Upload</button>
                </div>
            </form>
        </div>
    </div>

    <style>
        .char-count {
            font-size: 12px;
            color: #666;
            text-align: right;
            margin-top: 2px;
        }
        .char-count-exceeded {
            font-size: 12px;
            color: #FF0000;
            text-align: right;
            margin-top: 2px;
            font-weight: bold;
        }
        textarea.textarea-class {
            transition: border 0.3s ease;
        }
        textarea.textarea-class:focus {
            outline: none;
        }
        
        /* Asset Upload Modal Styles */
        #assetUploadModal .modal-text {
            margin-bottom: 20px;
            text-align: center;
        }
        #assetUploadModal .modal-text h2 {
            margin-top: 0;
            color: #333;
        }
        #assetUploadModal .fileUpload {
            display: block;
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        #assetUploadModal .progressPercent {
            text-align: right;
            margin-bottom: 5px;
            font-size: 12px;
        }
        #assetUploadModal .modal-buttons {
            display: flex;
            justify-content: flex-end;
            margin-top: 20px;
        }
        #assetUploadModal .cancel-btn {
            background-color: #f0f0f0;
            border: none;
            padding: 10px 15px;
            margin-right: 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        #assetUploadModal .upload-btn {
            background-color: #9662f9;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
        }
        /* Enhanced preview controls */
.preview-controls {
    margin-top: 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.preview-instructions {
    padding: 8px;
    background-color: #f0f4ff;
    border: 1px solid #d1d9ff;
    border-radius: 4px;
    font-size: 12px;
    color: #4a5568;
    text-align: center;
}

.preview-actions {
    display: flex;
    justify-content: center;
    gap: 8px;
}

.preview-btn {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 6px 12px;
    font-size: 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: white;
    color: #555;
    cursor: pointer;
    transition: all 0.2s ease;
}

.preview-btn:hover:not(:disabled) {
    background-color: #f8f9fa;
    border-color: #bbb;
}

.preview-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    background-color: #f5f5f5;
}

.reset-btn:hover:not(:disabled) {
    background-color: #fff5f5;
    border-color: #feb2b2;
    color: #c53030;
}

.undo-btn:hover:not(:disabled) {
    background-color: #f0f4ff;
    border-color: #864AF9;
    color: #864AF9;
}

/* Enhanced segment styling */
.subtitle-segment {
    display: inline-block;
    padding: 2px 4px;
    margin: 1px;
    border-radius: 3px;
    border: 1px solid transparent;
    transition: all 0.2s ease;
    cursor: pointer;
    position: relative;
}

.subtitle-segment:hover {
    background-color: #e8f0fe;
    border-color: #864AF9;
}

.subtitle-segment.exceeds-limit {
    background-color: #fff5f5;
    border-color: #feb2b2;
    color: #c53030;
}

.subtitle-segment.exceeds-limit:hover {
    background-color: #fed7d7;
}

.subtitle-segment.mergeable-next {
    border-right: 2px dashed #28a745;
}

.subtitle-segment.mergeable-prev {
    border-left: 2px dashed #28a745;
}

.subtitle-segment.merge-preview {
    background-color: #e8f5e8;
    border-color: #28a745;
}

.split-point {
    display: inline-block;
    width: 2px;
    height: 1.2em;
    background-color: #864AF9;
    margin: 0 1px;
    vertical-align: middle;
    animation: blink 1s infinite;
    cursor: pointer;
    position: relative;
}

.split-point:hover {
    background-color: #c53030;
    width: 3px;
}

.split-point::before {
    content: '×';
    position: absolute;
    top: -8px;
    left: -4px;
    font-size: 10px;
    color: #864AF9;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.split-point:hover::before {
    opacity: 1;
    color: #c53030;
}

/* Segment numbering on hover */
.subtitle-segment::before {
    content: attr(data-segment-number);
    position: absolute;
    top: -12px;
    left: 2px;
    font-size: 9px;
    color: #666;
    background: white;
    padding: 1px 3px;
    border-radius: 2px;
    opacity: 0;
    transition: opacity 0.2s ease;
    pointer-events: none;
}

.subtitle-segment:hover::before {
    opacity: 1;
}

/* Warning message for clip replacement */
.replacement-warning {
    margin-bottom: 15px;
}

.replacement-warning div {
    font-size: 13px;
    line-height: 1.4;
}

.replacement-warning strong {
    color: #856404;
}


/* Enhanced styles for word boundary splitting */
.word-boundary-mode {
    cursor: text;
}

.word-boundary-mode:hover {
    cursor: crosshair;
}

.preview-text.splitting-mode {
    background-color: #f8f9ff;
    border-color: #864AF9;
    cursor: crosshair;
}

/* Word boundary indicators */
.subtitle-segment.word-splittable {
    background: linear-gradient(to right, transparent 0%, rgba(134, 74, 249, 0.1) 50%, transparent 100%);
}

.subtitle-segment.word-splittable:hover {
    background: linear-gradient(to right, rgba(134, 74, 249, 0.1) 0%, rgba(134, 74, 249, 0.2) 50%, rgba(134, 74, 249, 0.1) 100%);
}

/* Enhanced split point styling */
.split-point {
    display: inline-block;
    width: 3px;
    height: 1.2em;
    background: linear-gradient(to bottom, #864AF9 0%, #9c7afc 100%);
    margin: 0 2px;
    vertical-align: middle;
    animation: pulse 2s infinite;
    cursor: pointer;
    position: relative;
    border-radius: 1px;
}

.split-point:hover {
    background: linear-gradient(to bottom, #c53030 0%, #e53e3e 100%);
    width: 4px;
    animation: none;
}

@keyframes pulse {
    0%, 100% { opacity: 1; transform: scaleY(1); }
    50% { opacity: 0.7; transform: scaleY(0.8); }
}

.split-point::before {
    content: '×';
    position: absolute;
    top: -10px;
    left: -3px;
    font-size: 10px;
    color: #864AF9;
    opacity: 0;
    transition: opacity 0.2s ease;
    font-weight: bold;
}

.split-point:hover::before {
    opacity: 1;
    color: #c53030;
}

/* Improved segment styling for word boundaries */
.subtitle-segment::after {
    content: '';
    position: absolute;
    bottom: -2px;
    left: 0;
    right: 0;
    height: 1px;
    background: transparent;
    transition: background 0.2s ease;
}

.subtitle-segment:hover::after {
    background: linear-gradient(to right, transparent 0%, #864AF9 20%, #864AF9 80%, transparent 100%);
}
.custom-split-preview {
    /* background: linear-gradient(135deg, #fff7ed 0%, #fed7aa 100%);
    border: 2px solid #fb923c; */
    border-radius: 12px;
    padding: 16px;
    margin: 0;
}

.custom-split-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 1px solid #fb923c;
}

.custom-split-header strong {
    color: #9a3412;
    font-size: 16px;
}

.split-count {
    background: #9a3412;
    color: white;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 600;
}

.custom-split-segments {
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-height: 300px;
    overflow-y: auto;
}

.custom-split-segment {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 12px;
    background: white;
    border-radius: 8px;
    border: 1px solid #fed7aa;
    transition: all 0.2s ease;
}

.custom-split-segment:hover {
    background: #fffbf5;
    border-color: #fb923c;
}

.custom-split-segment.exceeds-limit {
    background: #fef2f2;
    border-color: #f87171;
}

.segment-number {
    background: linear-gradient(135deg, #fb923c 0%, #f97316 100%);
    color: white;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 11px;
    font-weight: bold;
    flex-shrink: 0;
}

.custom-split-segment.exceeds-limit .segment-number {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
}

.segment-text {
    flex: 1;
    font-size: 13px;
    line-height: 1.4;
    color: #374151;
}

.segment-length {
    font-size: 11px;
    color: #6b7280;
    background: #f3f4f6;
    padding: 3px 6px;
    border-radius: 4px;
    font-weight: 500;
    min-width: 60px;
    text-align: center;
}

.custom-split-segment.exceeds-limit .segment-length {
    background: #fecaca;
    color: #991b1b;
}

/* File upload styling improvements */
.custom-file-input {
    position: relative;
    overflow: hidden;
}

.custom-file-input:hover .upload-arrow {
    transform: translateX(4px);
    transition: transform 0.2s ease;
}

.file-status {
    animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Drag and drop styling */
.custom-file-input.dragover {
    border-color: #864AF9 !important;
    background-color: #f8f9ff !important;
    transform: scale(1.02);
}

    </style>
<script>        const video_type = "{{ video.dimensions }}";
        console.log("Video type:", video_type);
        window.VIDEOTYPE = video_type;
</script>
<script src="{% static 'js/progress.js' %}"></script>
<script src="{% static 'js/header-toggle.js' %}"></script>
<script src="{% static 'js/scene.js' %}"></script>
<script src="{% static 'js/local-scene.js' %}"></script>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://code.jquery.com/ui/1.13.1/jquery-ui.min.js"></script>

    <script>
const videoHistoryId = "{{ video.history_id|default:'' }}";

// Add these new variables for enhanced splitting
let isLoadingHistory = false;

let selectedHistoryId = null;
let splitHistory = []; // Track split history for undo functionality
let maxHistorySize = 20; // Maximum undo history
let splittingMode = false;
let splitPositions = [];
let previewText = '';
let currentHistoryItem = null;
let historySplitFile = null;
let historySplitFileName = "No file chosen";
let customSplitLines = null;
        // Add subscription plan check variable
        const userSubscriptionPlan = "{{ user_subscription.plan.name|default:'Free Plan'|lower }}";
        const isFreePlan = false; // Default to false
        {% comment %} const isFreePlan = userSubscriptionPlan.toLowerCase().includes('free'); {% endcomment %}
        console.log("User plan:", userSubscriptionPlan, "Is free plan:", isFreePlan);
        
        console.log("User plan:", userSubscriptionPlan, "Is free plan:", isFreePlan);

// Apply free plan restrictions on load - more robust implementation
document.addEventListener('DOMContentLoaded', function() {
    if(isFreePlan) {
        // Get the upload card
        const uploadCard = document.getElementById('uploadCard');
        
        if(uploadCard) {
            // Make sure the upload card has position: relative
            uploadCard.style.position = 'relative';
            
            // Check if overlay exists, if not create it
            let freeUserOverlay = document.getElementById('freeUserOverlay');
            if(!freeUserOverlay) {
                freeUserOverlay = document.createElement('div');
                freeUserOverlay.id = 'freeUserOverlay';
                freeUserOverlay.innerHTML = `
                    <div>
                        <h3>Asset Upload Restricted</h3>
                        <p>This feature is only available for premium users. Upgrade your subscription to access asset uploads and other premium features.</p>
                        <a href="{% url 'manage_subscription' %}" class="upgrade-button">Upgrade Now</a>
                    </div>
                `;
                uploadCard.appendChild(freeUserOverlay);
            }
            
            // Make sure the overlay is displayed
            freeUserOverlay.style.display = 'flex';
            
            // Disable input and button
            const fileInput = document.getElementById('fileInput');
            const uploadButton = document.getElementById('videoUploadButton');
            
            if(fileInput) {
                fileInput.disabled = true;
                fileInput.title = "Upgrade to premium to use this feature";
            }
            
            if(uploadButton) {
                uploadButton.disabled = true;
                uploadButton.style.opacity = '0.5';
                uploadButton.title = "Upgrade to premium to use this feature";
            }
        }
        
        // Monitor subtitle count for free users
        checkSubtitleLimit();
    }
});
        // Check subtitle limits for free users
        function checkSubtitleLimit() {
            if(!isFreePlan) return true;
            
            const subtitleCount = slides ? slides.length : 0;
            const createLeadBtn = document.getElementById('createLeadBtn');
            const subtitleLimitError = document.getElementById('subtitle-limit-error');
            
            console.log("Current subtitle count:", subtitleCount);
            
            if(subtitleCount > 10) {
                // Disable add button
                if(createLeadBtn) {
                    createLeadBtn.style.opacity = '0.5';
                    createLeadBtn.style.pointerEvents = 'none';
                }
                
                // Show error message
                if(subtitleLimitError) {
                    subtitleLimitError.style.display = 'block';
                }
                
                return false;
            } else {
                // Enable add button
                if(createLeadBtn) {
                    createLeadBtn.style.opacity = '1';
                    createLeadBtn.style.pointerEvents = 'auto';
                }
                
                // Hide error message
                if(subtitleLimitError) {
                    subtitleLimitError.style.display = 'none';
                }
                
                return true;
            }
        }
        
        // Override file upload validation 
        document.querySelector('form[enctype="multipart/form-data"]').addEventListener('submit', function(e) {
            if(isFreePlan) {
                const fileInput = document.querySelector('input[name="videotextfile"]');
                if(fileInput && fileInput.files && fileInput.files[0]) {
                    // Read the file to check how many lines (subtitles) it contains
                    // and check if any line exceeds the character limit
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const content = event.target.result;
                        const lines = content.split('\n').filter(line => line.trim() !== '');
                        
                        // Access MAX_SUBTITLE_LENGTH from window object to ensure we use the one from scene.js
                        const maxLength = window.MAX_SUBTITLE_LENGTH || 100;
                        
                        // Check character limit for each line
                        const exceededLines = lines.filter(line => line.length > maxLength);
                        
                        if(exceededLines.length > 0) {
                            e.preventDefault();
                            alert(`${exceededLines.length} line(s) in your file exceed the ${maxLength} character limit. Please edit your file and try again.`);
                            return false;
                        }
                        
                        if(lines.length > 10) {
                            e.preventDefault();
                            alert('Free plan users are limited to 10 subtitles. Your file contains ' + lines.length + ' lines. Please upload a smaller file or upgrade your subscription.');
                            return false;
                        }
                        // If acceptable, let the form submit
                        e.target.submit();
                    };
                    
                    e.preventDefault(); // Prevent default while we check the file
                    reader.readAsText(fileInput.files[0]);
                }
            } else {
                // For premium users, only check character limits
                const fileInput = document.querySelector('input[name="videotextfile"]');
                if(fileInput && fileInput.files && fileInput.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const content = event.target.result;
                        const lines = content.split('\n').filter(line => line.trim() !== '');
                        
                        // Access MAX_SUBTITLE_LENGTH from window object
                        const maxLength = window.MAX_SUBTITLE_LENGTH || 100;
                        
                        // Check character limit for each line
                        const exceededLines = lines.filter(line => line.length > maxLength);
                        
                        if(exceededLines.length > 0) {
                            e.preventDefault();
                            alert(`${exceededLines.length} line(s) in your file exceed the ${maxLength} character limit. Please edit your file and try again.`);
                            return false;
                        }
                        
                        // If acceptable, let the form submit
                        e.target.submit();
                    };
                    
                    e.preventDefault(); // Prevent default while we check the file
                    reader.readAsText(fileInput.files[0]);
                }
            }
        });
        
        // Modify loadScript to enforce subtitle limits
        const originalLoadScript = loadScript;
        loadScript = function(clips) {
            originalLoadScript(clips);
            
            // Check subtitle limits after loading script
            setTimeout(checkSubtitleLimit, 100);
        };
        
        // Override createLeadBtn click handler to check limits
        document.getElementById('createLeadBtn').addEventListener('click', function(e) {
            if(isFreePlan) {
                const subtitleCount = slides ? slides.length : 0;
                
                if(subtitleCount > 10) {
                    e.preventDefault();
                    const subtitleLimitError = document.getElementById('subtitle-limit-error');
                    if(subtitleLimitError) {
                        subtitleLimitError.style.display = 'block';
                    }
                    return false;
                }
            }
        });
        
        // Debug output of clips from Django
        let clips = [];
        {% for clip in clips %}
                clips.push({
                    id: {{ clip.id|default:"0" }},
                    text: "{{ clip.text|escapejs }}".trim(),
                    sequence: {{ clip.sequence|default:"0" }},
                });
            console.log("Clip: {{ clip.id|default:'0' }} - {{ clip.text|escapejs }}");
        {% endfor %}
        loadScript(clips, true); // true indicates we want to replace existing clips


        // Pass subclips data directly from Django to JavaScript
        let initialSubclips = [];
        {% if subclips %}
            {% for subclip in subclips %}
                initialSubclips.push({
                    clip_id: {{ subclip.clip.id }},
                    subclip_id: {{ subclip.id }},
                    text: "{{ subclip.text|escapejs }}",
                    video_file: "{{ subclip.video_file.url|default:'' |escapejs }}"
                });
            {% endfor %}
        {% endif %}
        
        // Initialize highlighting with subclips data
        if (initialSubclips.length > 0) {
            document.addEventListener('DOMContentLoaded', () => {
                // Wait for loadScript to finish before processing subclips
                setTimeout(() => {
                    processInitialSubclips(initialSubclips);
                }, 300);
            });
        }
        
        // Make sure to set up event listeners for highlighted text after they're loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Add drag and drop functionality for split file
const fileUploadWrapper = document.querySelector('.custom-file-input');
if (fileUploadWrapper) {
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        fileUploadWrapper.addEventListener(eventName, preventDefaults, false);
    });
    
    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }
    
    ['dragenter', 'dragover'].forEach(eventName => {
        fileUploadWrapper.addEventListener(eventName, () => {
            fileUploadWrapper.classList.add('dragover');
        }, false);
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
        fileUploadWrapper.addEventListener(eventName, () => {
            fileUploadWrapper.classList.remove('dragover');
        }, false);
    });
    
    fileUploadWrapper.addEventListener('drop', (e) => {
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            document.getElementById('historySplitFile').files = files;
            handleHistorySplitFileChange({ target: { files: files } });
        }
    }, false);
}
            document.getElementById('historySplitFile')?.addEventListener('change', handleHistorySplitFileChange);

            setTimeout(() => {
                // Add click handlers for all highlighted text
                document.querySelectorAll('mark.handlePopupSubmit').forEach(mark => {
                    mark.addEventListener('click', (e) => {
                        const slideId = parseInt(e.target.closest('[data-id]').dataset.id);
                        selectedSlideId = slideId;
                        selectedText = e.target.textContent;
                        popupOpen = true;
                        renderPopup();
                    });
                });
            }, 500);
        });

        // Store asset folders and their files
        let assetFolders = {};
        {% for folder in asset_folders %}
            assetFolders["{{ folder.name }}"] = [];
            {% for asset in folder.assets %}
                {% if asset.content_type and asset.content_type|slice:":5" == "video" %}
                assetFolders["{{ folder.name }}"].push({
                    id: {{ asset.id }},
                    filename: "{{ asset.filename|escapejs }}",
                    key: "{{ asset.key|escapejs }}",
                    url: "{{ asset.s3_url }}"
                });
                {% endif %}
            {% endfor %}
            console.log("Added folder: {{ folder.name }} with {{ folder.assets|length }} total assets");
        {% endfor %}

function handleTopicChange(event) {
    const selectedTopic = event.target.value;
    console.log("Topic selected:", selectedTopic);
    popupTopic = selectedTopic;
    
    // Clear file input when dropdown is used
    const fileInput = document.getElementById('slide_file');
    if (fileInput) {
        fileInput.value = '';
        popupFile = null;
        
        // Reset file upload UI
        const uploadText = document.getElementById("upload-text");
        if (uploadText) {
            uploadText.textContent = "Choose or Drag File";
        }
        
        const clearFileBtn = document.getElementById("clear-file");
        if (clearFileBtn) {
            clearFileBtn.style.display = "none";
        }
    }
    
    // Show/hide video clips based on the selected folder
    const videoSelect = document.getElementById('videoSelect');
    if (!videoSelect) return;

    // Clear previous selection
    videoSelect.value = "";
    popupVideoClip = "";
    
    // Reset all options to hidden
    const allOptions = videoSelect.querySelectorAll('option');
    allOptions.forEach(option => {
        if (option.value !== "") { // Don't hide the default "Select A Video Clip" option
            option.style.display = 'none';
            option.disabled = true;
        }
    });
    const allOptGroups = videoSelect.querySelectorAll('optgroup');
    allOptGroups.forEach(optgroup => {
        optgroup.style.display = 'none'; // Hide all optgroups initially
    });
    
    // Show only options for the selected folder
    const selectedOptgroup = videoSelect.querySelector(`optgroup[data-folder="${selectedTopic}"]`);
    if (selectedOptgroup) {
        // Make the optgroup visible
        selectedOptgroup.style.display = 'block';
        
        // Enable and show all options within this optgroup
        const optionsInGroup = selectedOptgroup.querySelectorAll('option');
        optionsInGroup.forEach(option => {
            option.style.display = 'block';
            option.disabled = false;
        });
    }
    
    // Update submit button state
    const submitButton = document.getElementById('submit-clip');
    if (submitButton) {
        submitButton.disabled = true;
    }
}

        function handleVideoClipChange(event) {
            const selectedVideo = event.target.value;
            console.log("Video selected:", selectedVideo);
            popupVideoClip = selectedVideo;
            
            // Clear file input when video is selected
            const fileInput = document.getElementById('slide_file');
            if (fileInput) {
                fileInput.value = '';
                popupFile = null;
                
                // Reset file upload UI
                const uploadText = document.getElementById("upload-text");
                if (uploadText) {
                    uploadText.textContent = "Choose or Drag File";
                }
                
                const clearFileBtn = document.getElementById("clear-file");
                if (clearFileBtn) {
                    clearFileBtn.style.display = "none";
                }
            }
            
            // Enable submit button
            const submitButton = document.getElementById('submit-clip');
            if (submitButton) {
                submitButton.disabled = !selectedVideo;
            }
        }

        // These functions are for selecting and handling files in the popup
  function handlePopupFileChange(e) {
    console.log("File change event triggered");
    const fileInput = document.getElementById('slide_file');
    
    if (fileInput && fileInput.files && fileInput.files.length > 0) {
        popupFile = fileInput.files[0];
        const fileName = popupFile.name;
        const fileSizeMB = popupFile.size / (1024 * 1024); // convert bytes to MB

        // 500 MB size limit
        if (fileSizeMB > 500) {
            alert("File size exceeds 500MB. Please choose a smaller file.");
            fileInput.value = ''; // Reset the file input
            popupFile = null;

            // Reset UI
            const uploadText = document.getElementById("upload-text");
            if (uploadText) {
                uploadText.textContent = "Choose or Drag File";
            }

            const clearFileBtn = document.getElementById("clear-file");
            if (clearFileBtn) {
                clearFileBtn.style.display = "none";
            }

            const submitButton = document.getElementById("submit-clip");
            if (submitButton) {
                submitButton.disabled = true;
            }

            return;
        }

        console.log("File selected:", fileName);
        
        // Clear dropdown selections when file is chosen
        const topicSelect = document.getElementById('selected_topic');
        const videoSelect = document.getElementById('videoSelect');
        
        if (topicSelect) {
            topicSelect.value = "";
            popupTopic = "";
        }
        
        if (videoSelect) {
            videoSelect.value = "";
            popupVideoClip = "";
        }
        
        // Update upload text UI
        const uploadText = document.getElementById("upload-text");
        if (uploadText) {
            const lastDotIndex = fileName.lastIndexOf('.');
            const nameWithoutExt = lastDotIndex !== -1 ? fileName.substring(0, lastDotIndex) : '';
            const extension = lastDotIndex !== -1 ? fileName.substring(lastDotIndex) : '';
            const truncatedName = nameWithoutExt.length > 7 ? nameWithoutExt.substring(0, 7) : nameWithoutExt;
            uploadText.textContent = truncatedName + extension;
        }
        
        // Show clear file button
        const clearFileBtn = document.getElementById("clear-file");
        if (clearFileBtn) {
            clearFileBtn.style.display = "inline";
        }
        
        // Enable submit button
        const submitButton = document.getElementById("submit-clip");
        if (submitButton) {
            submitButton.disabled = false;
        }
    } else {
        console.log("No file selected or file input not found");
        popupFile = null;
        
        // Reset UI
        const uploadText = document.getElementById("upload-text");
        if (uploadText) {
            uploadText.textContent = "Choose or Drag File";
        }
        
        // Hide clear file button
        const clearFileBtn = document.getElementById("clear-file");
        if (clearFileBtn) {
            clearFileBtn.style.display = "none";
        }
        
        // Disable submit button if no video clip selected
        const submitButton = document.getElementById("submit-clip");
        if (submitButton) {
            submitButton.disabled = !popupVideoClip;
        }
    }
}


        function clearPopupFile() {
            console.log("Clearing file selection");
            popupFile = null;
            
            // Reset file input
            const fileInput = document.getElementById("slide_file");
            if (fileInput) {
                fileInput.value = '';
            }
            
            // Reset UI
            const uploadText = document.getElementById("upload-text");
            if (uploadText) {
                uploadText.textContent = "Choose or Drag File";
            }
            
            const clearFileBtn = document.getElementById("clear-file");
            if (clearFileBtn) {
                clearFileBtn.style.display = "none";
            }
            
            // Disable submit button if no video clip selected
            const submitButton = document.getElementById("submit-clip");
            if (submitButton) {
                submitButton.disabled = !popupVideoClip;
            }
        }

        // function handlePopupSubmit(e) {
        //     e.preventDefault();
        //     console.log("Submitting popup form...");
        //     console.log("FROM HTML")
            
        //     // Check for free plan restrictions
        //     if(isFreePlan) {
        //         const subtitleCount = slides ? slides.length : 0;
        //         if(subtitleCount >= 10) {
        //             popupErrorMessage = "Free plan users are limited to 10 subtitles. Please upgrade your subscription.";
        //             renderPopup();
        //             return;
        //         }
                
        //         // Ensure free users can't use asset selection even if they try to bypass UI
        //         const selectedTopic = document.getElementById('selected_topic')?.value;
        //         const selectedVideo = document.getElementById('videoSelect')?.value;
        //         const hasVideoSelection = selectedTopic && selectedVideo;
                
        //         if(hasVideoSelection) {
        //             popupErrorMessage = "Asset selection requires a premium subscription. Please upload a file instead.";
        //             renderPopup();
        //             return;
        //         }
        //     }
            
        //     // Check if file is selected
        //     const fileInput = document.getElementById('slide_file');
        //     const hasFile = fileInput && fileInput.files && fileInput.files.length > 0;
            
        //     console.log("File input exists:", !!fileInput);
        //     console.log("Files array exists:", !!(fileInput && fileInput.files));
        //     console.log("Files length:", fileInput && fileInput.files ? fileInput.files.length : 0);
        //     console.log("Has file:", hasFile);
        //     console.log("popupFile:", popupFile);
            
        //     // Check if asset is selected
        //     const selectedTopic = document.getElementById('selected_topic')?.value;
        //     const selectedVideo = document.getElementById('videoSelect')?.value;
        //     const hasVideoSelection = selectedTopic && selectedVideo;
            
        //     console.log("Selected topic:", selectedTopic);
        //     console.log("Selected video:", selectedVideo);
        //     console.log("Has video selection:", hasVideoSelection);
            
        //     // Validate that we have either a file or an asset selected
        //     if (!hasFile && !hasVideoSelection) {
        //         popupErrorMessage = "Please select a video file or choose a video from your assets.";
        //         console.log("Validation error:", popupErrorMessage);
        //         renderPopup();
        //         return;
        //     }
            
        //     // Get CSRF token from cookie
        //     function getCookie(name) {
        //         let cookieValue = null;
        //         if (document.cookie && document.cookie !== '') {
        //             const cookies = document.cookie.split(';');
        //             for (let i = 0; i < cookies.length; i++) {
        //                 const cookie = cookies[i].trim();
        //                 if (cookie.substring(0, name.length + 1) === (name + '=')) {
        //                     cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        //                     break;
        //                 }
        //             }
        //         }
        //         return cookieValue;
        //     }
            
        //     const csrftoken = getCookie('csrftoken');
        //     console.log("CSRF Token obtained:", !!csrftoken);
            
        //     // Process file upload
        //     if (hasFile) {
        //         console.log("Processing file upload");
        //         // Get the file from the input element directly to ensure we have the latest
        //         const file = fileInput.files[0];
        //         console.log("File to upload:", file.name, file.size, file.type);
                
        //         // Create FormData for file upload
        //         const formData = new FormData();
        //         formData.append('slide_file', file);
        //         formData.append('slide_text', selectedText);
        //         formData.append('clipId', selectedSlideId);
                
        //         console.log("FormData created with:", {
        //             slide_text: selectedText,
        //             clipId: selectedSlideId,
        //             file_name: file.name
        //         });
                
        //         // Send API request - CRITICAL PART FOR BACKEND
        //         console.log("Sending API request to /handle-clip-assignment/");
        //         fetch('/handle-clip-assignment/', {
        //             method: 'POST',
        //             headers: {
        //                 'X-CSRFToken': csrftoken
        //             },
        //             body: formData
        //         })
        //         .then(response => {
        //             console.log("API Response received:", response.status, response.statusText);
        //             return response.json();
        //         })
        //         .then(data => {
        //             console.log("API Response data:", data);
                    
        //             if (data.success) {
        //                 console.log("File upload successful:", data);
                        
        //                 // Store file in window object for later processing
        //                 if (!window.videoFiles) window.videoFiles = {};
        //                 const highlightId = `highlight_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
        //                 window.videoFiles[highlightId] = file;
                        
        //                 // Create a temporary URL for the file
        //                 const fileUrl = data.file_url || URL.createObjectURL(file);
        //                 console.log("File URL for highlight:", fileUrl);
                        
        //                 // Update highlighted text with video file
        //                 slides = slides.map(slide => {
        //                     if (slide.id === selectedSlideId) {
        //                         let newMarkedText = slide.markedText || slide.text || "";
                                
        //                         // Check if this text is already highlighted
        //                         const isAlreadyHighlighted = newMarkedText.includes(`<mark class="handlePopupSubmit">${selectedText}</mark>`) || 
        //                                                    new RegExp(`<mark class="handlePopupSubmit"[^>]*>${escapeRegExp(selectedText)}</mark>`, 'i').test(newMarkedText);
                                
        //                         // If it's already highlighted, remove the existing highlight first
        //                         if (isAlreadyHighlighted) {
        //                             // Remove the existing highlight for this text
        //                             const regex = new RegExp(`<mark class="handlePopupSubmit"[^>]*>${escapeRegExp(selectedText)}</mark>`, 'i');
        //                             newMarkedText = newMarkedText.replace(regex, selectedText);
        //                         }
                                
        //                         // Now add the new highlight with video file reference
        //                         const regex = new RegExp(`(${escapeRegExp(selectedText)})(?![^<]*>)`, "i");
        //                         newMarkedText = newMarkedText.replace(
        //                             regex,
        //                             `<mark class="handlePopupSubmit" data-highlight-id="${highlightId}" data-video-file="${fileUrl}">${selectedText}</mark>`
        //                         );
                                
        //                         return {
        //                             ...slide,
        //                             markedText: newMarkedText,
        //                             isEditing: false
        //                         };
        //                     }
        //                     return slide;
        //                 });
                        
        //                 console.log("Updated slide with file highlight, ID:", highlightId);
        //             } else {
        //                 console.error("File upload failed:", data.error);
        //                 popupErrorMessage = data.error || "Failed to upload the file. Please try again.";
        //                 renderPopup();
        //                 return;
        //             }
                    
        //             // Close popup and reset state
        //             popupOpen = false;
        //             popupFile = null;
        //             popupTopic = "";
        //             popupVideoClip = "";
        //             selectedText = "";
        //             selectedSlideId = null;
                    
        //             // Update UI
        //             renderSlides();
        //             closePopup();
                    
        //             console.log("Popup submitted successfully");
        //         })
        //         .catch(error => {
        //             console.error("API error:", error);
        //             console.error("Error details:", error.message, error.stack);
        //             popupErrorMessage = "An error occurred. Please try again.";
        //             renderPopup();
        //         });
        //     } 
        //     // Process asset selection
        //     else if (hasVideoSelection) {
        //         console.log("Processing asset selection");
                
        //         // Get the URL from the selected option's data-url attribute
        //         let fileUrl = "";
        //         const videoSelectElement = document.getElementById('videoSelect');
        //         if (videoSelectElement && videoSelectElement.selectedIndex >= 0) {
        //             const selectedOption = videoSelectElement.options[videoSelectElement.selectedIndex];
        //             fileUrl = selectedOption.dataset.url;
        //             console.log("Selected video URL:", fileUrl);
        //         }
                
        //         // Prepare data for the API request
        //         const data = {
        //             slide_text: selectedText,
        //             clipId: selectedSlideId,
        //             selected_topic: selectedTopic,
        //             selected_video: selectedVideo
        //         };
                
        //         console.log("Sending JSON data to API:", data);
                
        //         // Send API request - CRITICAL PART FOR BACKEND
        //         fetch('/handle-clip-assignment/', {
        //             method: 'POST',
        //             headers: {
        //                 'Content-Type': 'application/json',
        //                 'X-CSRFToken': csrftoken
        //             },
        //             body: JSON.stringify(data)
        //         })
        //         .then(response => {
        //             console.log("API Response received:", response.status, response.statusText);
        //             return response.json();
        //         })
        //         .then(data => {
        //             console.log("API Response data:", data);
                    
        //             if (data.success) {
        //                 console.log("Asset selection successful:", data);
                        
        //                 // Update highlighted text with asset reference
        //                 slides = slides.map(slide => {
        //                     if (slide.id === selectedSlideId) {
        //                         let newMarkedText = slide.markedText || slide.text || "";
                                
        //                         // Check if this text is already highlighted
        //                         const isAlreadyHighlighted = newMarkedText.includes(`<mark class="handlePopupSubmit">${selectedText}</mark>`) || 
        //                                                    new RegExp(`<mark class="handlePopupSubmit"[^>]*>${escapeRegExp(selectedText)}</mark>`, 'i').test(newMarkedText);
                                
        //                         // If it's already highlighted, remove the existing highlight first
        //                         if (isAlreadyHighlighted) {
        //                             // Remove the existing highlight for this text
        //                             const regex = new RegExp(`<mark class="handlePopupSubmit"[^>]*>${escapeRegExp(selectedText)}</mark>`, 'i');
        //                             newMarkedText = newMarkedText.replace(regex, selectedText);
        //                         }
                                
        //                         // Now add the new highlight with asset reference
        //                         const regex = new RegExp(`(${escapeRegExp(selectedText)})(?![^<]*>)`, "i");
        //                         newMarkedText = newMarkedText.replace(
        //                             regex,
        //                             `<mark class="handlePopupSubmit" data-topic="${selectedTopic}" data-video-key="${selectedVideo}" data-video-file="${data.file_url}">${selectedText}</mark>`
        //                         );
                                
        //                         return {
        //                             ...slide,
        //                             markedText: newMarkedText,
        //                             isEditing: false
        //                         };
        //                     }
        //                     return slide;
        //                 });
                        
        //                 console.log("Updated slide with asset highlight");
        //             } else {
        //                 console.error("Asset selection failed:", data.error);
        //                 popupErrorMessage = data.error || "Failed to assign the asset. Please try again.";
        //                 renderPopup();
        //                 return;
        //             }
                    
        //             // Close popup and reset state
        //             popupOpen = false;
        //             popupFile = null;
        //             popupTopic = "";
        //             popupVideoClip = "";
        //             selectedText = "";
        //             selectedSlideId = null;
                    
        //             // Update UI
        //             renderSlides();
        //             closePopup();
                    
        //             console.log("Popup submitted successfully");
        //         })
        //         .catch(error => {
        //             console.error("API error:", error);
        //             console.error("Error details:", error.message, error.stack);
        //             popupErrorMessage = "An error occurred. Please try again.";
        //             renderPopup();
        //         });
        //     }
        // }
    
    function handlePopupSubmit(e) {
    e.preventDefault();
    console.log("Submitting popup form...");
    
    // Check for free plan restrictions
    if(isFreePlan) {
        const subtitleCount = slides ? slides.length : 0;
        if(subtitleCount > 10) {
            popupErrorMessage = "Free plan users are limited to 10 subtitles. Please upgrade your subscription.";
            renderPopup();
            return;
        }
        
        // Ensure free users can't use asset selection even if they try to bypass UI
        const selectedTopic = document.getElementById('selected_topic')?.value;
        const selectedVideo = document.getElementById('videoSelect')?.value;
        const hasVideoSelection = selectedTopic && selectedVideo;
        
        if(hasVideoSelection) {
            popupErrorMessage = "Asset selection requires a premium subscription. Please upload a file instead.";
            renderPopup();
            return;
        }
    }
    
    // Check if file is selected
    const fileInput = document.getElementById('slide_file');
    const hasFile = fileInput && fileInput.files && fileInput.files.length > 0;
    
    // Check if asset is selected
    const selectedTopic = document.getElementById('selected_topic')?.value;
    const selectedVideo = document.getElementById('videoSelect')?.value;
    const hasVideoSelection = selectedTopic && selectedVideo;
    
    // Validate that we have either a file or an asset selected
    if (!hasFile && !hasVideoSelection) {
        popupErrorMessage = "Please select a video file or choose a video from your assets.";
        renderPopup();
        return;
    }
    
    // Store values before closing popup
    const savedSlideId = selectedSlideId;
    const savedText = selectedText;
    const savedFile = hasFile ? fileInput.files[0] : null;
    const savedTopic = selectedTopic;
    const savedVideo = selectedVideo;
    
    // Close popup immediately after validation
    popupOpen = false;
    popupFile = null;
    popupTopic = "";
    popupVideoClip = "";
    selectedText = "";
    selectedSlideId = null;
    
    // Render the popup closed and update UI
    closePopup();
    
    // Get CSRF token from cookie
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    const csrftoken = getCookie('csrftoken');
    
    // Process file upload
    if (hasFile) {
        console.log("Processing file upload in background");
        
        // Create a unique highlight ID for this upload
        const highlightId = `highlight_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
        
        // Add to pending uploads
        pendingUploads.add(highlightId);
        updateProceedButtonState();
        
        // Optimistically update the UI immediately - assume success
        slides = slides.map(slide => {
            if (slide.id === savedSlideId) {
                let newMarkedText = slide.markedText || slide.text || "";
                
                // Check if this text is already highlighted
                const isAlreadyHighlighted = newMarkedText.includes(`<mark class="handlePopupSubmit">${savedText}</mark>`) || 
                                           new RegExp(`<mark class="handlePopupSubmit"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i').test(newMarkedText);
                
                // If it's already highlighted, remove the existing highlight first
                if (isAlreadyHighlighted) {
                    const regex = new RegExp(`<mark class="handlePopupSubmit"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i');
                    newMarkedText = newMarkedText.replace(regex, savedText);
                }
                
                // Create a temporary URL for the file for immediate display
                const tempFileUrl = URL.createObjectURL(savedFile);
                
                // Now add the new highlight with temporary file reference
                const regex = new RegExp(`(${escapeRegExp(savedText)})(?![^<]*>)`, "i");
                newMarkedText = newMarkedText.replace(
                    regex,
                    `<mark class="handlePopupSubmit" data-highlight-id="${highlightId}" data-video-file="${tempFileUrl}" data-loading="true">${savedText}</mark>`
                );
                
                return {
                    ...slide,
                    markedText: newMarkedText,
                    isEditing: false
                };
            }
            return slide;
        });
        
        // Store file in window object for later processing
        if (!window.videoFiles) window.videoFiles = {};
        window.videoFiles[highlightId] = savedFile;
        
        // Update UI immediately
        renderSlides();
        
        // Create FormData for file upload
        const formData = new FormData();
        formData.append('slide_file', savedFile);
        formData.append('slide_text', savedText);
        formData.append('clipId', savedSlideId);
        
        // Send API request in the background
        const uploadPromise = fetch('/handle-clip-assignment/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrftoken
            },
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log("File upload successful:", data);
                
                // Update with the real server URL if provided
                if (data.file_url) {
                    slides = slides.map(slide => {
                        if (slide.id === savedSlideId) {
                            let newMarkedText = slide.markedText || "";
                            
                            // Replace the temporary URL with the permanent one
                            newMarkedText = newMarkedText.replace(
                                new RegExp(`data-highlight-id="${highlightId}"[^>]*data-loading="true"`, 'i'),
                                `data-highlight-id="${highlightId}" data-video-file="${data.file_url}"`
                            );
                            
                            return {
                                ...slide,
                                markedText: newMarkedText
                            };
                        }
                        return slide;
                    });
                    
                    // Update UI with permanent URL
                    renderSlides(false);
                }
            } else {
                console.error("File upload failed:", data.error);
                
                // If the upload failed, revert the highlight
                slides = slides.map(slide => {
                    if (slide.id === savedSlideId) {
                        let newMarkedText = slide.markedText || "";
                        
                        // Find and remove the temporary highlight
                        const regex = new RegExp(`<mark class="handlePopupSubmit"[^>]*data-highlight-id="${highlightId}"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i');
                        newMarkedText = newMarkedText.replace(regex, savedText);
                        
                        return {
                            ...slide,
                            markedText: newMarkedText
                        };
                    }
                    return slide;
                });
                
                // Remove the file from storage
                if (window.videoFiles && window.videoFiles[highlightId]) {
                    delete window.videoFiles[highlightId];
                }
                
                // Update UI
                renderSlides();
                
                // Show error notification
                showNotification("Upload failed: " + (data.error || "Unknown error"), "error");
            }
        })
        .catch(error => {
            console.error("API error:", error);
            
            // If the API call fails, revert the highlight
            slides = slides.map(slide => {
                if (slide.id === savedSlideId) {
                    let newMarkedText = slide.markedText || "";
                    
                    // Find and remove the temporary highlight
                    const regex = new RegExp(`<mark class="handlePopupSubmit"[^>]*data-highlight-id="${highlightId}"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i');
                    newMarkedText = newMarkedText.replace(regex, savedText);
                    
                    return {
                        ...slide,
                        markedText: newMarkedText
                    };
                }
                return slide;
            });
            
            // Remove the file from storage
            if (window.videoFiles && window.videoFiles[highlightId]) {
                delete window.videoFiles[highlightId];
            }
            
            // Update UI
            renderSlides();
            
            // Show error notification
            showNotification("Upload failed: Network error", "error");
        })
        .finally(() => {
            // Remove from pending uploads and update button state
            pendingUploads.delete(highlightId);
            updateProceedButtonState();
        });
        
        // Store the promise for potential cancellation
        uploadQueue.set(highlightId, uploadPromise);
    } 
    // Process asset selection
    else if (hasVideoSelection) {
        console.log("Processing asset selection in background");
        
        // Create a unique highlight ID for this selection
        const highlightId = `highlight_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
        
        // Add to pending uploads (even though it's not a file upload, it's still processing)
        pendingUploads.add(highlightId);
        updateProceedButtonState();
        
        // Get the URL from the selected option's data-url attribute
        let fileUrl = "";
        const videoSelectElement = document.getElementById('videoSelect');
        if (videoSelectElement && videoSelectElement.selectedIndex >= 0) {
            const selectedOption = videoSelectElement.options[videoSelectElement.selectedIndex];
            fileUrl = selectedOption.dataset.url || "";
        }
        
        // Optimistically update the UI immediately - assume success
        slides = slides.map(slide => {
            if (slide.id === savedSlideId) {
                let newMarkedText = slide.markedText || slide.text || "";
                
                // Check if this text is already highlighted
                const isAlreadyHighlighted = newMarkedText.includes(`<mark class="handlePopupSubmit">${savedText}</mark>`) || 
                                           new RegExp(`<mark class="handlePopupSubmit"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i').test(newMarkedText);
                
                // If it's already highlighted, remove the existing highlight first
                if (isAlreadyHighlighted) {
                    const regex = new RegExp(`<mark class="handlePopupSubmit"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i');
                    newMarkedText = newMarkedText.replace(regex, savedText);
                }
                
                // Now add the new highlight with asset reference
                const regex = new RegExp(`(${escapeRegExp(savedText)})(?![^<]*>)`, "i");
                newMarkedText = newMarkedText.replace(
                    regex,
                    `<mark class="handlePopupSubmit" data-highlight-id="${highlightId}" data-topic="${savedTopic}" data-video-key="${savedVideo}" data-video-file="${fileUrl}" data-loading="true">${savedText}</mark>`
                );
                
                return {
                    ...slide,
                    markedText: newMarkedText,
                    isEditing: false
                };
            }
            return slide;
        });
        
        // Update UI immediately
        renderSlides();
        
        // Prepare data for the API request
        const data = {
            slide_text: savedText,
            clipId: savedSlideId,
            selected_topic: savedTopic,
            selected_video: savedVideo
        };
        
        // Send API request in background
        const uploadPromise = fetch('/handle-clip-assignment/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify(data)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log("Asset selection successful:", data);
                
                // Update with the real server URL if provided
                if (data.file_url) {
                    slides = slides.map(slide => {
                        if (slide.id === savedSlideId) {
                            let newMarkedText = slide.markedText || "";
                            
                            // Replace the temporary loading attribute
                            newMarkedText = newMarkedText.replace(
                                new RegExp(`data-highlight-id="${highlightId}"[^>]*data-loading="true"`, 'i'),
                                `data-highlight-id="${highlightId}" data-topic="${savedTopic}" data-video-key="${savedVideo}" data-video-file="${data.file_url}"`
                            );
                            
                            return {
                                ...slide,
                                markedText: newMarkedText
                            };
                        }
                        return slide;
                    });
                    
                    // Update UI
                    renderSlides(false);
                }
            } else {
                console.error("Asset selection failed:", data.error);
                
                // If the selection failed, revert the highlight
                slides = slides.map(slide => {
                    if (slide.id === savedSlideId) {
                        let newMarkedText = slide.markedText || "";
                        
                        // Find and remove the temporary highlight
                        const regex = new RegExp(`<mark class="handlePopupSubmit"[^>]*data-highlight-id="${highlightId}"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i');
                        newMarkedText = newMarkedText.replace(regex, savedText);
                        
                        return {
                            ...slide,
                            markedText: newMarkedText
                        };
                    }
                    return slide;
                });
                
                // Update UI
                renderSlides();
                
                // Show error notification
                showNotification("Asset selection failed: " + (data.error || "Unknown error"), "error");
            }
        })
        .catch(error => {
            console.error("API error:", error);
            
            // If the API call fails, revert the highlight
            slides = slides.map(slide => {
                if (slide.id === savedSlideId) {
                    let newMarkedText = slide.markedText || "";
                    
                    // Find and remove the temporary highlight
                    const regex = new RegExp(`<mark class="handlePopupSubmit"[^>]*data-highlight-id="${highlightId}"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i');
                    newMarkedText = newMarkedText.replace(regex, savedText);
                    
                    return {
                        ...slide,
                        markedText: newMarkedText
                    };
                }
                return slide;
            });
            
            // Update UI
            renderSlides();
            
            // Show error notification
            showNotification("Asset selection failed: Network error", "error");
        })
        .finally(() => {
            // Remove from pending uploads and update button state
            pendingUploads.delete(highlightId);
            updateProceedButtonState();
        });
        
        // Store the promise for potential cancellation
        uploadQueue.set(highlightId, uploadPromise);
    }
}

// Add this new function
function updateProceedButtonState() {
    const btn = document.querySelector('.button-container-btn');
    const buttonText = document.getElementById('button-text');
    
    if (!btn || !buttonText) return;
    
    const shouldEnable = shouldEnableProceedButton();
    
    if (shouldEnable) {
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
        buttonText.textContent = "Proceed To Background Music Selection";
    } else {
        btn.disabled = true;
        btn.style.opacity = '0.5';
        btn.style.cursor = 'not-allowed';
        
        // Show appropriate message based on state
        if (pendingUploads.size > 0) {
            buttonText.textContent = `Uploading...`;
        } else if (!areAllTextareasHidden()) {
            buttonText.textContent = "Save your edits first";
        } else {
            buttonText.textContent = "Proceed To Background Music Selection";
        }
    }
}
    {% comment %} function handlePopupSubmit(e) {
    e.preventDefault();
    console.log("Submitting popup form...");
    
    // Check for free plan restrictions
    if(isFreePlan) {
        const subtitleCount = slides ? slides.length : 0;
        if(subtitleCount > 10) {
            popupErrorMessage = "Free plan users are limited to 10 subtitles. Please upgrade your subscription.";
            renderPopup();
            return;
        }
        
        // Ensure free users can't use asset selection even if they try to bypass UI
        const selectedTopic = document.getElementById('selected_topic')?.value;
        const selectedVideo = document.getElementById('videoSelect')?.value;
        const hasVideoSelection = selectedTopic && selectedVideo;
        
        if(hasVideoSelection) {
            popupErrorMessage = "Asset selection requires a premium subscription. Please upload a file instead.";
            renderPopup();
            return;
        }
    }
    
    // Check if file is selected
    const fileInput = document.getElementById('slide_file');
    const hasFile = fileInput && fileInput.files && fileInput.files.length > 0;
    
    // Check if asset is selected
    const selectedTopic = document.getElementById('selected_topic')?.value;
    const selectedVideo = document.getElementById('videoSelect')?.value;
    const hasVideoSelection = selectedTopic && selectedVideo;
    
    // Validate that we have either a file or an asset selected
    if (!hasFile && !hasVideoSelection) {
        popupErrorMessage = "Please select a video file or choose a video from your assets.";
        renderPopup();
        return;
    }
    
    // Store values before closing popup
    const savedSlideId = selectedSlideId;
    const savedText = selectedText;
    const savedFile = hasFile ? fileInput.files[0] : null;
    const savedTopic = selectedTopic;
    const savedVideo = selectedVideo;
    
    // Close popup immediately after validation
    popupOpen = false;
    popupFile = null;
    popupTopic = "";
    popupVideoClip = "";
    selectedText = "";
    selectedSlideId = null;
    
    // Render the popup closed and update UI
    closePopup();
    
    // Get CSRF token from cookie
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    const csrftoken = getCookie('csrftoken');
    
    // Process file upload
    if (hasFile) {
        console.log("Processing file upload in background");
        
        // Create a unique highlight ID for this upload
        const highlightId = `highlight_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
        
        // Optimistically update the UI immediately - assume success
        slides = slides.map(slide => {
            if (slide.id === savedSlideId) {
                let newMarkedText = slide.markedText || slide.text || "";
                
                // Check if this text is already highlighted
                const isAlreadyHighlighted = newMarkedText.includes(`<mark class="handlePopupSubmit">${savedText}</mark>`) || 
                                           new RegExp(`<mark class="handlePopupSubmit"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i').test(newMarkedText);
                
                // If it's already highlighted, remove the existing highlight first
                if (isAlreadyHighlighted) {
                    const regex = new RegExp(`<mark class="handlePopupSubmit"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i');
                    newMarkedText = newMarkedText.replace(regex, savedText);
                }
                
                // Create a temporary URL for the file for immediate display
                const tempFileUrl = URL.createObjectURL(savedFile);
                
                // Now add the new highlight with temporary file reference
                const regex = new RegExp(`(${escapeRegExp(savedText)})(?![^<]*>)`, "i");
                newMarkedText = newMarkedText.replace(
                    regex,
                    `<mark class="handlePopupSubmit" data-highlight-id="${highlightId}" data-video-file="${tempFileUrl}" data-loading="true">${savedText}</mark>`
                );
                
                return {
                    ...slide,
                    markedText: newMarkedText,
                    isEditing: false
                };
            }
            return slide;
        });
        
        // Store file in window object for later processing
        if (!window.videoFiles) window.videoFiles = {};
        window.videoFiles[highlightId] = savedFile;
        
        // Update UI immediately
        renderSlides();
        
        // Create FormData for file upload
        const formData = new FormData();
        formData.append('slide_file', savedFile);
        formData.append('slide_text', savedText);
        formData.append('clipId', savedSlideId);
        
        // Send API request in the background
        fetch('/handle-clip-assignment/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrftoken
            },
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log("File upload successful:", data);
                
                // Update with the real server URL if provided
                if (data.file_url) {
                    slides = slides.map(slide => {
                        if (slide.id === savedSlideId) {
                            let newMarkedText = slide.markedText || "";
                            
                            // Replace the temporary URL with the permanent one
                            newMarkedText = newMarkedText.replace(
                                new RegExp(`data-highlight-id="${highlightId}"[^>]*data-loading="true"`, 'i'),
                                `data-highlight-id="${highlightId}" data-video-file="${data.file_url}"`
                            );
                            
                            return {
                                ...slide,
                                markedText: newMarkedText
                            };
                        }
                        return slide;
                    });
                    
                    // Update UI with permanent URL
                    renderSlides(false);
                }
            } else {
                console.error("File upload failed:", data.error);
                
                // If the upload failed, revert the highlight
                slides = slides.map(slide => {
                    if (slide.id === savedSlideId) {
                        let newMarkedText = slide.markedText || "";
                        
                        // Find and remove the temporary highlight
                        const regex = new RegExp(`<mark class="handlePopupSubmit"[^>]*data-highlight-id="${highlightId}"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i');
                        newMarkedText = newMarkedText.replace(regex, savedText);
                        
                        return {
                            ...slide,
                            markedText: newMarkedText
                        };
                    }
                    return slide;
                });
                
                // Remove the file from storage
                if (window.videoFiles && window.videoFiles[highlightId]) {
                    delete window.videoFiles[highlightId];
                }
                
                // Update UI
                renderSlides();
                
                // Show error notification
                showNotification("Upload failed: " + (data.error || "Unknown error"), "error");
            }
        })
        .catch(error => {
            console.error("API error:", error);
            
            // If the API call fails, revert the highlight
            slides = slides.map(slide => {
                if (slide.id === savedSlideId) {
                    let newMarkedText = slide.markedText || "";
                    
                    // Find and remove the temporary highlight
                    const regex = new RegExp(`<mark class="handlePopupSubmit"[^>]*data-highlight-id="${highlightId}"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i');
                    newMarkedText = newMarkedText.replace(regex, savedText);
                    
                    return {
                        ...slide,
                        markedText: newMarkedText
                    };
                }
                return slide;
            });
            
            // Remove the file from storage
            if (window.videoFiles && window.videoFiles[highlightId]) {
                delete window.videoFiles[highlightId];
            }
            
            // Update UI
            renderSlides();
            
            // Show error notification
            showNotification("Upload failed: Network error", "error");
        });
    } 
    // Process asset selection
    else if (hasVideoSelection) {
        console.log("Processing asset selection in background");
        
        // Create a unique highlight ID for this selection
        const highlightId = `highlight_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
        
        // Get the URL from the selected option's data-url attribute
        let fileUrl = "";
        const videoSelectElement = document.getElementById('videoSelect');
        if (videoSelectElement && videoSelectElement.selectedIndex >= 0) {
            const selectedOption = videoSelectElement.options[videoSelectElement.selectedIndex];
            fileUrl = selectedOption.dataset.url || "";
        }
        
        // Optimistically update the UI immediately - assume success
        slides = slides.map(slide => {
            if (slide.id === savedSlideId) {
                let newMarkedText = slide.markedText || slide.text || "";
                
                // Check if this text is already highlighted
                const isAlreadyHighlighted = newMarkedText.includes(`<mark class="handlePopupSubmit">${savedText}</mark>`) || 
                                           new RegExp(`<mark class="handlePopupSubmit"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i').test(newMarkedText);
                
                // If it's already highlighted, remove the existing highlight first
                if (isAlreadyHighlighted) {
                    const regex = new RegExp(`<mark class="handlePopupSubmit"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i');
                    newMarkedText = newMarkedText.replace(regex, savedText);
                }
                
                // Now add the new highlight with asset reference
                const regex = new RegExp(`(${escapeRegExp(savedText)})(?![^<]*>)`, "i");
                newMarkedText = newMarkedText.replace(
                    regex,
                    `<mark class="handlePopupSubmit" data-highlight-id="${highlightId}" data-topic="${savedTopic}" data-video-key="${savedVideo}" data-video-file="${fileUrl}" data-loading="true">${savedText}</mark>`
                );
                
                return {
                    ...slide,
                    markedText: newMarkedText,
                    isEditing: false
                };
            }
            return slide;
        });
        
        // Update UI immediately
        renderSlides();
        
        // Prepare data for the API request
        const data = {
            slide_text: savedText,
            clipId: savedSlideId,
            selected_topic: savedTopic,
            selected_video: savedVideo
        };
        
        // Send API request in background
        fetch('/handle-clip-assignment/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify(data)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log("Asset selection successful:", data);
                
                // Update with the real server URL if provided
                if (data.file_url) {
                    slides = slides.map(slide => {
                        if (slide.id === savedSlideId) {
                            let newMarkedText = slide.markedText || "";
                            
                            // Replace the temporary loading attribute
                            newMarkedText = newMarkedText.replace(
                                new RegExp(`data-highlight-id="${highlightId}"[^>]*data-loading="true"`, 'i'),
                                `data-highlight-id="${highlightId}" data-topic="${savedTopic}" data-video-key="${savedVideo}" data-video-file="${data.file_url}"`
                            );
                            
                            return {
                                ...slide,
                                markedText: newMarkedText
                            };
                        }
                        return slide;
                    });
                    
                    // Update UI
                    renderSlides(false);
                }
            } else {
                console.error("Asset selection failed:", data.error);
                
                // If the selection failed, revert the highlight
                slides = slides.map(slide => {
                    if (slide.id === savedSlideId) {
                        let newMarkedText = slide.markedText || "";
                        
                        // Find and remove the temporary highlight
                        const regex = new RegExp(`<mark class="handlePopupSubmit"[^>]*data-highlight-id="${highlightId}"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i');
                        newMarkedText = newMarkedText.replace(regex, savedText);
                        
                        return {
                            ...slide,
                            markedText: newMarkedText
                        };
                    }
                    return slide;
                });
                
                // Update UI
                renderSlides();
                
                // Show error notification
                showNotification("Asset selection failed: " + (data.error || "Unknown error"), "error");
            }
        })
        .catch(error => {
            console.error("API error:", error);
            
            // If the API call fails, revert the highlight
            slides = slides.map(slide => {
                if (slide.id === savedSlideId) {
                    let newMarkedText = slide.markedText || "";
                    
                    // Find and remove the temporary highlight
                    const regex = new RegExp(`<mark class="handlePopupSubmit"[^>]*data-highlight-id="${highlightId}"[^>]*>${escapeRegExp(savedText)}</mark>`, 'i');
                    newMarkedText = newMarkedText.replace(regex, savedText);
                    
                    return {
                        ...slide,
                        markedText: newMarkedText
                    };
                }
                return slide;
            });
            
            // Update UI
            renderSlides();
            
            // Show error notification
            showNotification("Asset selection failed: Network error", "error");
        });
    }
} {% endcomment %}

// Helper function to show notifications
function showNotification(message, type = "info") {
    // Create notification element if it doesn't exist
    let notification = document.getElementById('notification-popup');
    if (!notification) {
        notification = document.createElement('div');
        notification.id = 'notification-popup';
        notification.className = 'notification';
        document.body.appendChild(notification);
    }
    
    // Set notification type class
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    // Show notification
    notification.style.display = 'block';
    notification.style.opacity = '1';
    
    // Hide notification after 3 seconds
    setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
            notification.style.display = 'none';
        }, 300);
    }, 3000);
}

// Add this CSS to your page for notifications
function addNotificationStyles() {
    const style = document.createElement('style');
    style.textContent = `
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 4px;
            color: white;
            font-weight: 500;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .notification.info {
            background-color: #3498db;
        }
        
        .notification.success {
            background-color: #2ecc71;
        }
        
        .notification.error {
            background-color: #e74c3c;
        }
        
        .notification.warning {
            background-color: #f39c12;
        }
        
        /* Add loading indicator for highlights that are being processed */
        mark.handlePopupSubmit[data-loading="true"] {
            background-color: rgba(134, 74, 249, 0.3);
            position: relative;
            
        }
        
        mark.handlePopupSubmit[data-loading="true"]:after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent);
            animation: loading-shine 1.5s infinite;
        }
        
        @keyframes loading-shine {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }
    `;
    document.head.appendChild(style);
}

// Call this function on page load
document.addEventListener('DOMContentLoaded', addNotificationStyles);
    
        function renderPopup() {
            let popup = document.querySelector('.popup-modal');
            if (!popup) {
                popup = document.createElement('div');
                popup.className = 'popup-modal';
                document.body.appendChild(popup);
            }
            popup.style.display = popupOpen ? 'flex' : 'none';
            if (popupOpen) {
                // Check if free user to apply restrictions
                const assetsDisabled = isFreePlan ? 'disabled' : '';
                const assetsStyle = isFreePlan ? 'opacity:0.; pointer-events:none;' : '';
                const assetsMessage = isFreePlan ? '<p style="color:#ff5555;font-size:11px;margin:5px 0 0;text-align:center;">Asset selection requires premium plan</p>' : '';
                
                popup.innerHTML = `
                    <div class="popup-container">
                        <div class="close-btnx close-btn"onclick="closePopup()">
                            <button class="close-popup" >X</button>
                        </div>
                        <div id="modal-cont">
                            <form class="popup-content" style="grid-template-columns: 0.7fr 1fr; width: 100%;" onsubmit="handlePopupSubmit(event)">
                                <br>
                                <input type="hidden" name="csrfmiddlewaretoken" value="">
                                <div id="submit-cont">
                                <div class="form-group" style=" padding-left: 0px; padding-right: 0px;">
                                <h4 style="margin-bottom: 15px; margin-top: 0px; color: rgb(51, 51, 51);">Selected Text:</h4>
                                <div style="margin-bottom: 15px; padding: 7px; background: rgb(240, 240, 240); border-radius: 6px; border: 1px solid rgb(224, 224, 224); font-size: 18px; color: rgb(25, 25, 25);">${selectedText}</div></div>
                                    <div class="form-group">
                                        <input id="slide_text" hidden name="slide_text" value="${selectedText}" readonly class="form-input">
                                    </div>
                                    <input id="clipId" type="number" hidden name="clipId" value="2298" readonly>
                                    <input type="text" hidden id="remaining" name="remaining" value="starting with a tingling sensation in my back." readonly>
                                    <div style="display: grid; grid-template-columns: 0.85fr 1fr; border-radius: 8px; border: 1px solid #00000080; overflow: hidden;" class="form-grid-cont">
                                        <div class="grid-item title form-grid-item begin column-1">
                                            <span style="height: 50px; align-items: center;">Upload Scene</span>
                                        </div>
                                        <div class="grid-item title form-grid-item end column-2" style="${assetsStyle}">
                                            <span style="height: 50px; align-items: center; margin-left: -18px;">Upload Scene From Assets Folder</span>
                                        </div>
                                        <div class="form-grid-item main-item">
                                            <div class="form-group" style="height: 100%;">
                                                <div class="upload-container" id="drop-zone">
                                                    <label for="slide_file" class="upload-label">
                                                        <img src="{% static 'images/upload.svg' %}" alt="" class="uploadSvg">
                                                        <span id="upload-text">${popupFile ? popupFile.name.slice(0, 7) + (popupFile.name.includes('.') ? popupFile.name.slice(popupFile.name.lastIndexOf('.')) : '') : 'Choose or Drag File'}</span>
                                                    </label>
                                                    <i id="clear-file" style="display: ${popupFile ? 'inline' : 'none'};" onclick="clearPopupFile()" class="ri-close-circle-line"></i>
                                                    <input type="file" id="slide_file" name="slide_file" class="upload-input" accept="video/*,image/*" onchange="handlePopupFileChange(event)">
                                                </div>
                                            </div>
                                        </div>
                                        <div style="border-left: 0.8px solid #864AF9; ${assetsStyle}" class="form-grid-item">
                                            <div class="form-group">
                                                <select id="selected_topic" name="selected_topic" class="form-select" onchange="handleTopicChange(event)" ${assetsDisabled}>
                                                    <option value="" ${!popupTopic ? 'selected' : ''}>Select Folder</option>
                                                    {% for asset_folder in asset_folders %}
                                                    <option value="{{ asset_folder.name }}" ${popupTopic === "{{ asset_folder.name }}" ? 'selected' : ''}>{{ asset_folder.name }}</option>
                                                    {% endfor %}
                                                </select>
                                            </div>
                                            <div class="form-group">
                                                <select id="videoSelect" name="selected_video" class="form-select" onchange="handleVideoClipChange(event)" ${assetsDisabled}>
                                    <option value="" disabled ${!popupVideoClip ? 'selected' : ''}>Select A Video Clip</option>
                                    {% for asset_folder in asset_folders %}
                                        <optgroup label="{{ asset_folder.name }}" data-folder="{{ asset_folder.name }}" style="display: none;">
                                            {% for video in asset_folder.assets %}
                                            <option value="{{ video.key }}" data-url="{{ video.s3_url }}" style="display: none;" disabled>{{ video.filename }}</option>
                                            {% endfor %}
                                        </optgroup>
                                    {% endfor %}
                                </select>
                                                ${assetsMessage}
                                                <p style="color: red; font-size: 13px; margin-top: 5px;" id="error-slide">${popupErrorMessage}</p>
                                            </div>
                                            <input type="number" hidden id="is_tiktok" name="is_tiktok" value="0" readonly>
                                        </div>
                                    </div>
                                </div>
                                <div style="align-items: end;" class="form-group ai-form">
                                ${isFreePlan ? 
                                    `<a href="javascript:void(0);" id="ai-clip" style="display: flex; align-items: center; color: #864AF9;">
                                        Click For AI Scene Suggestions
                                        <span style="margin-left: 5px; font-size: 12px; color: #ff5555; font-weight: bold; display: inline-flex; align-items: center;">
                                            <span style="border: 1px solid #ff5555; border-radius: 4px; padding: 1px 4px; margin-left: 4px;">Premium</span>
                                        </span>
                                    </a>` : 
                                    `<a href="javascript:void(0);" id="ai-clip">Click For AI Scene Suggestions</a>`
                                }
                                    <button type="submit" id="submit-clip" class="submit-btn" ${popupFile || (!isFreePlan && popupTopic && popupVideoClip) ? '' : 'disabled'}>
                                        Submit
                                    </button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;
            }

            const dropZone = document.getElementById('drop-zone');
                if (dropZone) {
                    ['dragenter', 'dragover'].forEach(event => {
                        dropZone.addEventListener(event, e => {
                            e.preventDefault();
                            dropZone.classList.add('drag-over');
                        });
                    });

                    ['dragleave', 'dragend', 'drop'].forEach(event => {
                        dropZone.addEventListener(event, e => {
                            e.preventDefault();
                            dropZone.classList.remove('drag-over');
                        });
                    });

                    dropZone.addEventListener('drop', e => {
                        e.preventDefault();
                        const files = e.dataTransfer.files;
                        if (files.length > 0 && files[0].type.startsWith('video/')) {
                            const fileInput = document.getElementById('slide_file');
                            fileInput.files = files;
                            handlePopupFileChange({ target: fileInput });
                        } else {
                            showNotification("Only video files are allowed.", "error");
                        }
                    });
                }

        }
        // Function to handle AI scene suggestions button click
function handleAISceneSuggestions() {
    // Check if user is on free plan
    if (typeof isFreePlan !== 'undefined' && isFreePlan) {
        // Show premium feature modal
        const premiumModal = document.createElement('div');
        premiumModal.className = 'ai-modal';
        premiumModal.style.display = 'flex';
        premiumModal.innerHTML = `
            <div class="ai-modal-content" style="background-color: white; border-radius: 8px; padding: 30px; max-width: 450px; text-align: center; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);">
                <h2 style="font-family: 'Montserrat', sans-serif; font-size: 22px; font-weight: 600; margin-bottom: 15px; color: #191919;">Premium Feature</h2>
                <p style="font-family: 'Montserrat', sans-serif; font-size: 15px; line-height: 1.5; color: #555; margin-bottom: 25px;">
                    AI scene suggestions are only available for premium users. Upgrade your subscription to access this feature and more.
                </p>
                <a href="{% url 'manage_subscription' %}" style="display: inline-block; background-color: #864AF9; color: white; padding: 12px 28px; border-radius: 4px; text-decoration: none; font-weight: 500; font-family: 'Montserrat', sans-serif;">
                    Upgrade Now
                </a>
                <div style="margin-top: 20px;">
                    <button onclick="this.parentNode.parentNode.parentNode.remove()" style="background: none; border: none; color: #555; cursor: pointer; font-size: 14px; text-decoration: underline;">
                        Close
                    </button>
                </div>
            </div>
        `;
        document.body.appendChild(premiumModal);
        return;
    }
    
    // Get currently selected text from the popup
    const selectedText = document.getElementById('slide_text')?.value || '';
    
    if (!selectedText.trim()) {
        alert('Please select text first to get scene suggestions');
        return;
    }
    
    // Show loading state
    showAILoadingModal();
    
    // Get CSRF token
    const csrftoken = getCookie('csrftoken');
    
    // Make API call to generate scene suggestions
    fetch('/generate-scene-suggestions/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify({
            prompt: selectedText
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            showAISuggestionsModal(data);
        } else {
            showAIErrorModal(data.message || 'Failed to generate scene suggestions');
        }
    })
    .catch(error => {
        console.error('Error fetching scene suggestions:', error);
        showAIErrorModal('An error occurred while fetching scene suggestions');
    });
}

// Function to show loading modal
function showAILoadingModal() {
    // Create or get modal container
    let modal = document.getElementById('ai-suggestions-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'ai-suggestions-modal';
        modal.className = 'ai-modal';
        document.body.appendChild(modal);
    }
    
    // Set loading content
    modal.innerHTML = `
        <div class="ai-modal-content">
            <div class="ai-modal-header">
                <h3>Generating Scene Suggestions</h3>
                <button class="ai-modal-close" onclick="closeAIModal()">×</button>
            </div>
            <div class="ai-modal-body" style="text-align: center;">
                <div class="ai-loading-spinner"></div>
                <p>Our AI is generating creative scene suggestions for your text...</p>
            </div>
        </div>
    `;
    
    // Display modal
    modal.style.display = 'flex';
}

// Function to show suggestions modal
function showAISuggestionsModal(data) {
    // Create or get modal container
    let modal = document.getElementById('ai-suggestions-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'ai-suggestions-modal';
        modal.className = 'ai-modal';
        document.body.appendChild(modal);
    }
    
    // Generate suggestions HTML
    let suggestionsHTML = '';
    data.suggestions.forEach((suggestion, index) => {
        // Remove "Scene Description: " prefix if present
        let description = suggestion.description;
        if (description.startsWith('Scene Description: ')) {
            description = description.substring('Scene Description: '.length);
        }
        
        suggestionsHTML += `
            <div class="ai-suggestion-card">
                <div class="ai-suggestion-number">${index + 1}</div>
                <div class="ai-suggestion-content">
                    <p>${description}</p>
                    <div class="ai-suggestion-links">
                        <a href="${suggestion.pexels_url}" target="_blank" class="ai-link pexels-link">
                            <span>Pexels</span>
                        </a>
                        <a href="${suggestion.storyblocks_url}" target="_blank" class="ai-link storyblocks-link">
                            <span>Storyblocks</span>
                        </a>
                    </div>
                </div>
            </div>
        `;
    });
    
    // Set modal content
    modal.innerHTML = `
        <div class="ai-modal-content">
            <div class="ai-modal-header">
                <h3>AI Scene Suggestions</h3>
                <button class="ai-modal-close" onclick="closeAIModal()">×</button>
            </div>
            <div class="ai-modal-body">
                <p class="ai-intro">Here are some scene suggestions for: <strong>"${document.getElementById('slide_text')?.value || ''}"</strong></p>
                <div class="ai-suggestions-container">
                    ${suggestionsHTML}
                </div>
                <p class="ai-note">Click on Pexels or Storyblocks links to search for these scenes</p>
            </div>
        </div>
    `;
    
    // Display modal
    modal.style.display = 'flex';
}

// Function to show error modal
function showAIErrorModal(message) {
    // Create or get modal container
    let modal = document.getElementById('ai-suggestions-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'ai-suggestions-modal';
        modal.className = 'ai-modal';
        document.body.appendChild(modal);
    }
    
    // Set error content
    modal.innerHTML = `
        <div class="ai-modal-content">
            <div class="ai-modal-header">
                <h3>Error</h3>
                <button class="ai-modal-close" onclick="closeAIModal()">×</button>
            </div>
            <div class="ai-modal-body" style="text-align: center;">
                <p style="color: #ff5050;">${message}</p>
                <button class="ai-try-again-btn" onclick="closeAIModal()">Close</button>
            </div>
        </div>
    `;
    
    // Display modal
    modal.style.display = 'flex';
}

// Function to close AI modal
function closeAIModal() {
    const modal = document.getElementById('ai-suggestions-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// Helper function to get cookie (for CSRF token)
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// Update the rendering of popup to add event listener to AI suggestions button
const originalRenderPopup = renderPopup;
renderPopup = function() {
    // Call the original function first
    originalRenderPopup();
    
    // Add event listener to AI scene suggestions button
    const aiClipButton = document.getElementById('ai-clip');
    if (aiClipButton) {
        // Replace href with javascript:void(0) to prevent default link behavior
        aiClipButton.href = 'javascript:void(0)';
        // Add click event listener
        aiClipButton.addEventListener('click', handleAISceneSuggestions);
    }
};

// Add CSS styles for AI scene suggestions modal
const styleElement = document.createElement('style');
styleElement.textContent = `
    .ai-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        justify-content: center;
        align-items: center;
    }
    
    .ai-modal-content {
        background-color: #fff;
        width: 80%;
        max-width: 700px;
        max-height: 90vh;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    .ai-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 20px;
        background-color: #864AF9;
        color: white;
    }
    
    .ai-modal-header h3 {
        margin: 0;
        font-size: 18px;
    }
    
    .ai-modal-close {
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
        padding: 0;
        line-height: 1;
    }
    
    .ai-modal-body {
        padding: 20px;
        overflow-y: auto;
        flex: 1;
    }
    
    .ai-loading-spinner {
        border: 4px solid rgba(134, 74, 249, 0.3);
        border-radius: 50%;
        border-top: 4px solid #864AF9;
        width: 40px;
        height: 40px;
        animation: ai-spin 1s linear infinite;
        margin: 20px auto;
    }
    
    @keyframes ai-spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .ai-intro {
        margin-bottom: 20px;
        font-size: 15px;
    }
    
    .ai-suggestions-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
    }
    
    .ai-suggestion-card {
        display: flex;
        gap: 15px;
        background-color: #f9f9f9;
        border-radius: 8px;
        padding: 15px;
        border: 1px solid #e0e0e0;
    }
    
    .ai-suggestion-number {
        background-color: #864AF9;
        color: white;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        flex-shrink: 0;
    }
    
    .ai-suggestion-content {
        flex: 1;
    }
    
    .ai-suggestion-content p {
        margin-top: 0;
        margin-bottom: 15px;
        line-height: 1.5;
    }
    
    .ai-suggestion-links {
        display: flex;
        gap: 15px;
    }
    
    .ai-link {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 8px 16px;
        border-radius: 4px;
        text-decoration: none;
        font-weight: 500;
        transition: all 0.2s ease;
        min-width: 120px;
    }
    
    /* Removed img styling as we're not using images anymore */
    
    .pexels-link {
        background-color: #05A081;
        color: white;
    }
    
    .pexels-link:hover {
        background-color: #048b6f;
    }
    
    .storyblocks-link {
        background-color: #FF6B00;
        color: white;
    }
    
    .storyblocks-link:hover {
        background-color: #e05f00;
    }
    
    .ai-note {
        font-size: 13px;
        color: #666;
        margin-top: 20px;
        text-align: center;
    }
    
    .ai-try-again-btn {
        background-color: #864AF9;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
        margin-top: 15px;
    }
    
    .ai-try-again-btn:hover {
        background-color: #7038e0;
    }
`;
document.head.appendChild(styleElement);

// Initialize when document is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log('AI Scene Suggestions initialized');
});

// Draft handling functions
document.getElementById('saveDraftBtn').addEventListener('click', function() {
    document.getElementById('draftModal').style.display = 'flex';
});

document.getElementById('cancelDraft').addEventListener('click', function() {
    document.getElementById('draftModal').style.display = 'none';
});

document.getElementById('saveDraftConfirm').addEventListener('click', function() {
    const draftName = document.getElementById('draftName').value.trim();
    if (!draftName) {
        alert('Please enter a draft name');
        return;
    }

    // Get current video ID from URL
    const videoId = window.location.pathname.split('/').filter(Boolean).pop();

    // Get CSRF token from cookie
    const csrftoken = getCookie('csrftoken');

    // Save draft
    fetch('/save-draft/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify({
            video_id: videoId,
            name: draftName
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('Draft saved successfully!');
            document.getElementById('draftModal').style.display = 'none';
            window.location.href = '/recent-videos/';
        } else {
            alert(data.error || 'Failed to save draft');
        }
    })
    .catch(error => {
        alert('Failed to save draft');
    });
});

// Close modal when clicking outside
window.onclick = function(event) {
    const modal = document.getElementById('draftModal');
    if (event.target == modal) {
        modal.style.display = 'none';
    }
};



// #####################################
// Add these variables to your existing scene.js file
let voiceoverHistory = [];
let selectedHistoryItem = null;
let isHistoryLoaded = false;

async function loadVoiceoverHistory() {
    // Prevent duplicate calls
    if (isLoadingHistory || isHistoryLoaded) {
        console.log('History already loading or loaded, skipping duplicate call');
        return;
    }
    
    isLoadingHistory = true;
    console.log('Starting to load voiceover history...');
    
    const loadingElement = document.getElementById('history-loading');
    const errorElement = document.getElementById('history-error');
    const selectElement = document.getElementById('voiceover-history-select');
    
    // Show loading state
    loadingElement.style.display = 'flex';
    errorElement.style.display = 'none';
    selectElement.style.display = 'none';
    
    try {
        // Get video ID from URL
        const path = window.location.pathname;
        const videoId = path.split('/')[2];
        
        // Get CSRF token
        const csrftoken = getCookie('csrftoken');
        
        console.log('Loading voiceover history for video:', videoId);
        console.log('Video history_id to auto-select:', videoHistoryId);
        
        const response = await fetch(`/videos/${videoId}/voiceover-history/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrftoken,
                'Content-Type': 'application/json'
            }
        });
        
        const data = await response.json();
        console.log('Voiceover history response:', data);
        
        if (data.history && Array.isArray(data.history) && data.history.length > 0) {
            voiceoverHistory = data.history;
            console.log('Voiceover history loaded:', voiceoverHistory);
            populateHistoryDropdown(data.history);
            
            // Auto-select if video has history_id
            if (videoHistoryId && videoHistoryId.trim() !== '') {
                autoSelectHistoryItem(videoHistoryId);
            }
            
            isHistoryLoaded = true;
            
            // Hide loading, show dropdown
            loadingElement.style.display = 'none';
            selectElement.style.display = 'block';
            
            console.log(`Loaded ${data.history.length} voiceover history items`);
        } else {
            // No history found
            const message = data.error || 'No voiceover history found. Create some voiceovers in ElevenLabs first.';
            showHistoryError(message);
            console.log('No voiceover history:', message);
        }
    } catch (error) {
        console.error('Error loading voiceover history:', error);
        showHistoryError('Failed to load voiceover history. Please check your internet connection and try again.');
    } finally {
        isLoadingHistory = false; // Reset the loading flag
    }
}
// New function to auto-select history item based on history_id
async function autoSelectHistoryItem(historyId) {
    const selectElement = document.getElementById('voiceover-history-select');
    console.log('Attempting to fetch from saved history endpoint...');
    
    try {
        // Try to fetch from saved history endpoint
        const savedHistoryItem = await fetchSavedHistory(historyId);
        
        if (savedHistoryItem) {
            console.log('Successfully fetched saved history item:', savedHistoryItem);
            
            // Add the fetched item to the voiceoverHistory array
            voiceoverHistory.push(savedHistoryItem);
            
            // Add option to dropdown
            const option = document.createElement('option');
            const newIndex = voiceoverHistory.length - 1;
            option.value = newIndex;
            
            // Format the option text similar to other options
            console.log('Formatting option text for saved history item:', savedHistoryItem);
            const truncatedText = savedHistoryItem.text ? 
            (savedHistoryItem.text.length > 60 ? savedHistoryItem.text.substring(0, 60) + '...' : savedHistoryItem.text) :
            (savedHistoryItem.dialogue?.[0]?.text ? 
            (savedHistoryItem.dialogue[0].text.length > 60 ? savedHistoryItem.dialogue[0].text.substring(0, 60) + '...' : savedHistoryItem.dialogue[0].text) :
            'No text available');
        
            
            option.textContent = `${truncatedText}`;
            option.style.fontWeight = 'bold';
            option.style.backgroundColor = '#f0f8ff';
            option.dataset.historyItem = JSON.stringify(savedHistoryItem);
            
            selectElement.appendChild(option);
            
            // Auto-select the newly added item
            await selectHistoryItemAtIndex(newIndex, true);
            
            console.log('Auto-selected saved history item');
        }
    } catch (error) {
        console.error('Failed to fetch saved history:', error);
        
        // Show error message
        const errorElement = document.getElementById('history-error');
        if (errorElement) {
            errorElement.innerHTML = `
                <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 10px; margin-top: 15px;">
                    <span style="color: #856404; font-weight: 500;">⚠️ Notice:</span>
                    <span style="color: #856404;"> The previously linked voiceover (ID: ${historyId}) could not be loaded. It may have been deleted from ElevenLabs.</span>
                </div>
            `;
            errorElement.style.display = 'block';
        }
//     }
}
}
// Modified populateHistoryDropdown to support auto-selection
function populateHistoryDropdown(history) {
    const selectElement = document.getElementById('voiceover-history-select');
    
    // Clear existing options except the first one
    selectElement.innerHTML = '<option value="">Select a voiceover...</option>';
    
    history.forEach((item, index) => {
        const option = document.createElement('option');
        option.value = index;
        
        // Format the option text
        const truncatedText = item.text ? 
            (item.text.length > 60 ? item.text.substring(0, 60) + '...' : item.text) :
            (item.dialogue?.[0]?.text ? 
            (item.dialogue[0].text.length > 60 ? item.dialogue[0].text.substring(0, 60) + '...' : item.dialogue[0].text) :
            'No text available');
        
        // Calculate relative time
        const now = Math.floor(Date.now() / 1000);
        const diff = now - item.date_unix;
        
        let timeAgo;
        if (diff < 60) {
            timeAgo = `${diff} seconds ago`;
        } else if (diff < 3600) {
            const mins = Math.floor(diff / 60);
            timeAgo = `${mins} ${mins === 1 ? 'minute' : 'minutes'} ago`;
        } else if (diff < 86400) {
            const hours = Math.floor(diff / 3600);
            const mins = Math.floor((diff % 3600) / 60);
            timeAgo = `${hours} ${hours === 1 ? 'hour' : 'hours'}${mins > 0 ? ` ${mins} min` : ''} ago`;
        } else if (diff < 2592000) {
            const days = Math.floor(diff / 86400);
            const hours = Math.floor((diff % 86400) / 3600);
            timeAgo = `${days} ${days === 1 ? 'day' : 'days'}${hours > 0 ? ` ${hours} hr` : ''} ago`;
        } else {
            const months = Math.floor(diff / 2592000);
            const days = Math.floor((diff % 2592000) / 86400);
            timeAgo = `${months} ${months === 1 ? 'month' : 'months'}${days > 0 ? ` ${days} d` : ''} ago`;
        }
        
        option.textContent = `${truncatedText} (${timeAgo})`;
        option.dataset.historyItem = JSON.stringify(item);
        
        // Add visual indicator if this is the linked voiceover
        const itemId = item.history_item_id || item.id || '';
        // if (videoHistoryId && itemId.toString() === videoHistoryId.toString()) {
        //     option.textContent += ' ★'; // Add star to indicate linked voiceover
        //     option.style.fontWeight = 'bold';
        //     option.style.backgroundColor = '#f0f8ff';
        // }
        
        selectElement.appendChild(option);
    });
    
    // Add event listener for selection change (remove existing listener first)
    selectElement.removeEventListener('change', handleHistorySelection);
    selectElement.addEventListener('change', handleHistorySelection);
}

// Enhanced showTab function to check for auto-selection
function showTab(tabName = 'history') {
    tabName = 'history'; // Force to history tab for this example
    // Hide all tab contents first
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });
    
    // Remove active class from all tab buttons
    document.querySelectorAll('.tab-button').forEach(button => {
        button.classList.remove('active');
    });
    
    // Show selected tab content
    console.log(`Showing tab: ${tabName}`);
    if (!document.getElementById(`${tabName}-content`)) {
        console.error(`Tab content for ${tabName} not found`);
        return;
    }
    document.getElementById(`${tabName}-content`).classList.add('active');
    document.getElementById(`${tabName}-tab`).classList.add('active');
    
    // Load voiceover history when history tab is selected for the first time
    // But only if it hasn't been loaded yet
    if (tabName === 'history' && !isHistoryLoaded) {
        console.log('Loading voiceover history from showTab function');
        loadVoiceoverHistory();
    }
}
// Also update the DOMContentLoaded event to handle auto-selection if starting on history tab
// Update the DOMContentLoaded event to prevent double loading
document.addEventListener('DOMContentLoaded', () => {
    // Log the video history_id for debugging
    if (videoHistoryId && videoHistoryId.trim() !== '') {
        console.log('Video has linked history_id:', videoHistoryId);
    } else {
        console.log('Video has no linked history_id');
    }
    
    // Set the active tab class but DON'T call showTab to prevent double loading
    document.getElementById('history-content').classList.add('active');
    document.getElementById('history-tab').classList.add('active');
    
    // Load voiceover history only once here
    if (!isHistoryLoaded) {
        loadVoiceoverHistory();
    }
    
    // Add event listeners for tab functionality
    const historyTab = document.getElementById('history-tab');
    if (historyTab) {
        historyTab.addEventListener('click', () => showTab('history'));
    }
    
    // Rest of your existing initialization code...
});

// Handle history selection from dropdown
function handleHistorySelection(event) {
    const selectedIndex = event.target.value;
    const loadButton = document.getElementById('historyLoadButton');
    const previewElement = document.getElementById('selected-history-preview');
    
    if (selectedIndex === '') {
        // No selection
        selectedHistoryItem = null;
        selectedHistoryId = null;
        loadButton.disabled = true;
        previewElement.style.display = 'none';
        return;
    }
    
    // Get selected history item
    selectedHistoryItem = voiceoverHistory[selectedIndex];
    selectedHistoryId = selectedHistoryItem.history_item_id || selectedHistoryItem.id || null;
        // If there's a custom split file loaded, re-validate it against this voiceover
    if (customSplitLines && customSplitLines.length > 0) {
        console.log('Re-validating custom split file against new voiceover selection');
        validateAndPreviewSplit(customSplitLines);
}
    console.log('Selected history item:', selectedHistoryItem);
    console.log('Selected history ID:', selectedHistoryId);
    
    // Enable load button
    loadButton.disabled = false;
    
    // Show preview
    showHistoryPreview(selectedHistoryItem);
}

// Enhanced preview function with text cleaning
function showHistoryPreview(historyItem) {
    const previewElement = document.getElementById('selected-history-preview');
    const voiceNameElement = document.getElementById('preview-voice-name');
    const textElement = document.getElementById('preview-text');
    const charCountElement = document.getElementById('preview-char-count');
    const dateElement = document.getElementById('preview-date');
    const subtitleCountElement = document.getElementById('preview-subtitle-count');
    
    // Store current history item for splitting
    currentHistoryItem = historyItem;
    
    // Get voice name with fallback
    const voiceName = historyItem.voice_name ||  (historyItem.dialogue?.[0]?.voice_name) || `Voice ${historyItem.voice_id || 'Unknown'}`;
    // Get text content, checking both text and dialogue properties
    const rawText = historyItem.text || 
                   (historyItem.dialogue?.[0]?.text) || 
                   'No text available';
    
    // Clean the text before processing
    const cleanedText = cleanPreviewText(rawText);
    
    // Store the cleaned preview text and reset state
    previewText = cleanedText;
    splitPositions = [];
    splitHistory = [];
    
    // Populate preview elements
    voiceNameElement.textContent = voiceName;
    
    // Initialize text with splitting functionality using cleaned text
    setupTextSplitting(textElement, cleanedText);
    
    // Show both original and cleaned character counts
    const originalLength = rawText.length;
    const cleanedLength = cleanedText.length;
    const reductionPercent = originalLength > 0 ? Math.round((1 - cleanedLength / originalLength) * 100) : 0;
    
    charCountElement.innerHTML = `
        ${cleanedLength} chars

    `;
    
    // Format date
    const date = new Date(historyItem.date_unix * 1000);
    dateElement.textContent = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    
    // Calculate initial subtitle count (single subtitle)
    updateSubtitleCount();
    updateUndoButtonState();
    
    // Add warning if there are existing slides
    const existingClipsCount = slides.filter(slide => slide.text && slide.text.trim() !== '').length;
    const existingWarning = previewElement.querySelector('.replacement-warning');
        if (existingWarning) {
            existingWarning.remove();
        }
    if (existingClipsCount > 0) {
        // Add warning message to preview
        const warningDiv = document.createElement('div');
        warningDiv.className = 'replacement-warning';
        warningDiv.innerHTML = `
            <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 8px; margin-bottom: 10px;">
                <strong>⚠️ Warning:</strong> Loading this script will replace all existing ${existingClipsCount} subtitle(s).
            </div>
        `;
        
        // Insert warning before preview details
        const previewDetails = previewElement.querySelector('.preview-details');
        previewDetails.parentNode.insertBefore(warningDiv, previewDetails);
    } 
    
    // Show cleaning info if significant changes were made
    if (reductionPercent > 10) {
        const cleaningInfo = document.createElement('div');
        cleaningInfo.className = 'cleaning-info';
        cleaningInfo.innerHTML = `
            <div style="background-color: #e8f5e8; border: 1px solid #b8e6b8; border-radius: 4px; padding: 6px; margin-bottom: 8px; font-size: 12px;">
                <strong>📝 Text Cleaned:</strong> Removed empty lines and normalized formatting (${reductionPercent}% reduction)
            </div>
        `;
        
        // Insert before preview details
        const previewDetails = previewElement.querySelector('.preview-details');
        previewDetails.parentNode.insertBefore(cleaningInfo, previewDetails);
    } else {
        // Remove any existing cleaning info
        const existingInfo = previewElement.querySelector('.cleaning-info');
        if (existingInfo) {
            existingInfo.remove();
        }
    }
    
    // Show preview
    previewElement.style.display = 'block';
    
    console.log('Showing enhanced preview for:', voiceName);
    console.log('Text cleaning applied - original:', originalLength, 'chars, cleaned:', cleanedLength, 'chars');
    console.log('Existing clips will be replaced:', existingClipsCount);
}

function estimateSubtitleCount(text) {
    if (!text) return 0;
    
    const maxLength = window.MAX_SUBTITLE_LENGTH || 100;
    
    // Simple estimation: split by sentences first, then by length
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    let estimatedCount = 0;
    
    for (let sentence of sentences) {
        sentence = sentence.trim();
        if (sentence.length === 0) continue;
        
        if (sentence.length <= maxLength) {
            estimatedCount += 1;
        } else {
            // Estimate how many subtitles this sentence would create
            estimatedCount += Math.ceil(sentence.length / maxLength);
        }
    }
    
    return Math.max(1, estimatedCount);
}

// Show error state for history loading
function showHistoryError(message) {
    const loadingElement = document.getElementById('history-loading');
    const errorElement = document.getElementById('history-error');
    const selectElement = document.getElementById('voiceover-history-select');
    
    loadingElement.style.display = 'none';
    selectElement.style.display = 'none';
    errorElement.style.display = 'block';
    
    errorElement.querySelector('.error-text').textContent = message;
}


// Function to restore saved preview HTML and splits
function restoreSavedPreview(savedHtml, savedSplitPositions, savedPreviewText) {
    const previewElement = document.getElementById('preview-text');
    
    if (!previewElement || !savedHtml) {
        console.log('Cannot restore preview: missing elements or HTML');
        return false;
    }
    
    try {
        // Restore the HTML
        previewElement.innerHTML = savedHtml;
        
        // Restore split positions and preview text if available
        if (savedSplitPositions && Array.isArray(savedSplitPositions)) {
            splitPositions = [...savedSplitPositions];
            console.log('Restored split positions:', splitPositions);
        }
        
        if (savedPreviewText) {
            previewText = savedPreviewText;
            console.log('Restored preview text');
        }
        
        // Restore event listeners
        setupPreviewEventListeners();
        
        // Update subtitle count
        updateSubtitleCount();
        updateUndoButtonState();
        
        console.log('Successfully restored saved preview with splits');
        return true;
    } catch (error) {
        console.error('Error restoring saved preview:', error);
        return false;
    }
}

// Helper function to set up event listeners after restoring HTML
function setupPreviewEventListeners() {
    const textElement = document.getElementById('preview-text');
    
    if (!textElement) return;
    
    // Re-add click event listener for splitting
    textElement.removeEventListener('click', handleTextSplit);
    textElement.addEventListener('click', handleTextSplit);
    
    // Re-add hover effects
    textElement.addEventListener('mouseenter', () => {
        if (!splittingMode) {
            textElement.classList.add('splitting-mode');
        }
    });
    
    textElement.addEventListener('mouseleave', () => {
        textElement.classList.remove('splitting-mode');
    });
    
    // Re-add event listeners to segments
    textElement.querySelectorAll('.subtitle-segment').forEach((segment, index) => {
        segment.addEventListener('mouseenter', () => showMergeIndicators(segment, index));
        segment.addEventListener('mouseleave', () => hideMergeIndicators(segment));
    });
}

// Enhanced function to update video history_id and save preview HTML
function updateVideoHistoryIdWithHtml(historyId, previewHtml = '') {
    return new Promise((resolve, reject) => {
        // Get video ID from the URL
        const path = window.location.pathname;
        const videoId = path.split('/')[2];
        
        // Get CSRF token from cookie
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        
        const csrftoken = getCookie('csrftoken');
        
        // Prepare data for the request - ADD preview_html
        const data = {
            video_id: videoId,
            history_id: historyId,
            preview_html: previewHtml,
            split_positions: splitPositions, // Also save split positions for reconstruction
            preview_text: previewText // Save the original cleaned text
        };
        
        console.log('Updating video history_id with HTML:', data);
        
        // Send AJAX request to update history_id and save HTML
        fetch('/update-video-history/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken,
            },
            body: JSON.stringify(data),
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log('Video history_id and HTML updated successfully:', data);
                resolve(data);
            } else {
                console.error('Error updating video history_id and HTML:', data.error);
                reject(new Error(data.error || 'Failed to update history_id and HTML'));
            }
        })
        .catch(error => {
            console.error('Network error updating history_id and HTML:', error);
            reject(error);
        });
    });
}
// Enhanced loadSelectedHistory function with custom splitting support
function loadSelectedHistory() {
    if (!selectedHistoryItem) {
        alert('Please select a voiceover from history first.');
        return;
    }
    
    const loadButton = document.getElementById('historyLoadButton');
    const originalText = loadButton.textContent;
    loadButton.textContent = 'Loading...';
    loadButton.disabled = true;
    
    try {
        console.log('Loading selected history with custom splitting support:', selectedHistoryItem.voice_name || selectedHistoryItem.voice_id);
        console.log('History ID to save:', selectedHistoryId);
        console.log('Custom split file provided:', !!customSplitLines);
        
        let segments;
        
        if (customSplitLines && customSplitLines.length > 0) {
            // Use custom split lines from uploaded file
            console.log('Using custom split from uploaded file');
            
            // Validate that the uploaded text matches the voiceover text
            const voiceoverText = cleanPreviewText(selectedHistoryItem.text || 
                                                  (selectedHistoryItem.dialogue?.[0]?.text) || '');
            const uploadedText = customSplitLines.join(' ').replace(/\s+/g, ' ').trim();
            const normalizedVoiceoverText = voiceoverText.replace(/\s+/g, ' ').trim();
            
            console.log('Comparing texts:');
            console.log('Voiceover text:', normalizedVoiceoverText.substring(0, 100) + '...');
            console.log('Uploaded text:', uploadedText.substring(0, 100) + '...');
            
            // Check if texts match (allowing for minor formatting differences)
            const similarity = calculateTextSimilarity(normalizedVoiceoverText, uploadedText);
            console.log('Text similarity:', similarity);
            console.log(normalizedVoiceoverText, uploadedText);
            if (similarity < 0.95) { // 95% similarity threshold
                alert('The uploaded text file does not match the selected voiceover content. Please ensure the text content is identical to your voiceover.');
                loadButton.textContent = originalText;
                loadButton.disabled = false;
                return;
            }
            
            segments = customSplitLines;
        } else {
            // Use manual splits from preview
            console.log('Using manual splits from preview');
            segments = getTextSegments();
        }
        
        if (segments.length === 0) {
            alert('No text content to load.');
            loadButton.textContent = originalText;
            loadButton.disabled = false;
            return;
        }
        
        // Validate all segments
        const maxLength = window.MAX_SUBTITLE_LENGTH || 80;
        const longSegments = segments.filter(segment => segment.trim().length > maxLength);
        
        if (longSegments.length > 0) {
            alert(`${longSegments.length} subtitle(s) exceed the ${maxLength} character limit. Please edit your file or split them further before loading.`);
            loadButton.textContent = originalText;
            loadButton.disabled = false;
            return;
        }
        
        // Check free plan restrictions
        if (typeof isFreePlan !== 'undefined' && isFreePlan && segments.length > 10) {
            alert(`Free plan users are limited to 10 subtitles. This would create ${segments.length} subtitles. Please upgrade your subscription or reduce the number of lines.`);
            loadButton.textContent = originalText;
            loadButton.disabled = false;
            return;
        }
        
        // Show confirmation dialog if there are existing clips
        if (slides.length > 0 && slides.some(slide => slide.text && slide.text.trim() !== '')) {
            const confirmReplace = confirm(
                `This will replace all existing ${slides.length} subtitle(s) with ${segments.length} new subtitle(s) from the selected voiceover.\n\n` +
                `${customSplitLines ? 'Using custom splitting from uploaded file.' : 'Using manual splits.'}\n\n` +
                `Are you sure you want to continue? This action cannot be undone.`
            );
            
            if (!confirmReplace) {
                loadButton.textContent = originalText;
                loadButton.disabled = false;
                return;
            }
        }
        
        // Get the current preview HTML to save (if using manual splits)
        const previewElement = document.getElementById('preview-text');
        const previewHtml = !customSplitLines && previewElement ? previewElement.innerHTML : '';
        
        // Update loading text to show deletion progress
        loadButton.textContent = 'Clearing existing clips...';
        
        // Delete all existing clips first, then update history_id with HTML, then load new clips
        deleteAllClips()
            .then(() => {
                loadButton.textContent = 'Saving configuration...';
                return updateVideoHistoryIdWithHtml(selectedHistoryId, previewHtml);
            })
            .then(() => {
                loadButton.textContent = 'Loading new subtitles...';
                
                // Create clips array from segments
                const clips = segments.map((segment, index) => ({
                    id: -(index + 1), // Use negative IDs for new clips
                    text: segment.trim(),
                    sequence: index + 1
                }));
                
                console.log('Created clips from segments:', clips);
                
                // Clear local slides array and reset state
                slides = [];
                slideCount = 0;
                activeSlideIds.clear();
                
                // Clear any existing video files from previous sessions
                if (window.videoFiles) {
                    window.videoFiles = {};
                }
                
                // Clear the custom split data after successful load
                customSplitLines = null;
                historySplitFile = null;
                historySplitFileName = "No file chosen";
                document.getElementById('historySplitFile').value = '';
                
                // Use existing loadScript function to load the clips
                loadScript(clips, true); // true indicates we want to replace existing clips
                
                // Reset button
                loadButton.textContent = originalText;
                loadButton.disabled = false;
                
                // Show success message
                const splitMethod = segments.length !== getTextSegments().length ? 'custom file splitting' : 'manual splitting';
                console.log(`Successfully replaced all clips with ${segments.length} subtitles using ${splitMethod}`);
                
                // Optional: Switch back to upload tab to show the loaded content
                setTimeout(() => {
                    showTab('upload');
                    
                    // Scroll to the editing area
                    const editingArea = document.getElementById('leadsTable');
                    if (editingArea) {
                        editingArea.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }, 500);
            })
            .catch(error => {
                console.error('Error in loading process:', error);
                loadButton.textContent = originalText;
                loadButton.disabled = false;
                
                alert('Failed to load the selected voiceover. Please try again.\n\nError: ' + error.message);
            });
        
    } catch (error) {
        console.error('Error loading selected history:', error);
        alert('Failed to load the selected voiceover. Please try again.');
        
        loadButton.textContent = originalText;
        loadButton.disabled = false;
    }
}
// Split text into appropriate subtitle chunks (word boundaries only)
function splitTextIntoSubtitles(text) {
    const maxLength = window.MAX_SUBTITLE_LENGTH || 80;
    
    // Clean the text first
    text = text.trim();
    
    // Split by sentences first, but ensure word boundaries
    const sentenceRegex = /[.!?]+\s+/;
    const sentences = text.split(sentenceRegex);
    const lines = [];
    
    for (let sentence of sentences) {
        sentence = sentence.trim();
        if (sentence.length === 0) continue;
        
        // If sentence is short enough, use it as is
        if (sentence.length <= maxLength) {
            lines.push(sentence);
        } else {
            // Split long sentences by word boundaries
            const words = sentence.split(/\s+/);
            let currentLine = '';
            
            for (let word of words) {
                // Check if adding this word would exceed the limit
                const potentialLine = currentLine ? currentLine + ' ' + word : word;
                
                if (potentialLine.length <= maxLength) {
                    currentLine = potentialLine;
                } else {
                    // Save current line if it exists
                    if (currentLine.length > 0) {
                        lines.push(currentLine);
                    }
                    
                    // Start new line with current word
                    if (word.length <= maxLength) {
                        currentLine = word;
                    } else {
                        // Handle extremely long words by keeping them as single lines
                        // but warn the user
                        lines.push(word);
                        currentLine = '';
                        console.warn(`Word "${word}" exceeds character limit but cannot be split`);
                    }
                }
            }
            
            // Add remaining current line
            if (currentLine.length > 0) {
                lines.push(currentLine);
            }
        }
    }
    
    // Final cleanup and validation
    return lines
        .map(line => line.trim())
        .filter(line => line.length > 0);
}

// Helper function to split text by words
function splitByWords(text, maxLength) {
    const words = text.split(' ');
    const lines = [];
    let currentLine = '';
    
    for (let word of words) {
        const potentialLine = currentLine ? currentLine + ' ' + word : word;
        
        if (potentialLine.length <= maxLength) {
            currentLine = potentialLine;
        } else {
            if (currentLine.length > 0) {
                lines.push(currentLine);
            }
            
            // Handle very long single words
            if (word.length > maxLength) {
                // Force split the word
                let remainingWord = word;
                while (remainingWord.length > maxLength) {
                    lines.push(remainingWord.substring(0, maxLength));
                    remainingWord = remainingWord.substring(maxLength);
                }
                currentLine = remainingWord;
            } else {
                currentLine = word;
            }
        }
    }
    
    if (currentLine.length > 0) {
        lines.push(currentLine);
    }
    
    return lines;
}

// Update the existing DOMContentLoaded event listener to include tab functionality
document.addEventListener('DOMContentLoaded', () => {
    // Existing initialization code...
    
    // Initialize tabs - default to upload tab
    showTab('history');
    
    // Add event listeners for tab functionality
    const historyTab = document.getElementById('history-tab');
    

    if (historyTab) {
        historyTab.addEventListener('click', () => showTab('history'));
    }
    
    // Rest of your existing initialization code...
    // Keep all the existing code from the original DOMContentLoaded
});

// Ensure getCookie function exists (add this if it's not already in your code)
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// Add this function to handle API errors gracefully
function handleApiError(error, context = 'API call') {
    console.error(`${context} failed:`, error);
    
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
        return 'Network error. Please check your internet connection.';
    }
    
    if (error.name === 'SyntaxError') {
        return 'Server response error. Please try again.';
    }
    
    return error.message || 'An unexpected error occurred.';
}

// Enhanced error handling for the API call
async function loadVoiceoverHistoryWithRetry(maxRetries = 2) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            await loadVoiceoverHistory();
            return; // Success, exit the retry loop
        } catch (error) {
            lastError = error;
            console.warn(`Attempt ${attempt} failed:`, error);
            
            if (attempt < maxRetries) {
                // Wait before retrying (exponential backoff)
                await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
            }
        }
    }
    
    // All retries failed
    const errorMessage = handleApiError(lastError, 'Loading voiceover history');
    showHistoryError(errorMessage);
}

// Add keyboard navigation for the dropdown
document.addEventListener('keydown', (event) => {
    const activeElement = document.activeElement;
    
    if (activeElement && activeElement.id === 'voiceover-history-select') {
        // Enter key to load selected history
        if (event.key === 'Enter' && selectedHistoryItem) {
            event.preventDefault();
            loadSelectedHistory();
        }
        
        // Escape key to clear selection
        if (event.key === 'Escape') {
            event.preventDefault();
            activeElement.value = '';
            handleHistorySelection({ target: activeElement });
        }
    }
});

// Add tooltips for better UX
function addTooltips() {
    const elements = [
        { id: 'upload-tab', text: 'Upload a text file with your script' },
        { id: 'history-tab', text: 'Select from your ElevenLabs voiceover history' },
        { id: 'voiceover-history-select', text: 'Choose a previously generated voiceover' },
        { id: 'historyLoadButton', text: 'Load the selected voiceover as subtitles' }
    ];
    
    elements.forEach(({ id, text }) => {
        const element = document.getElementById(id);
        if (element) {
            element.title = text;
        }
    });
}

// Call addTooltips after DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    // ... existing code ...
    addTooltips();
});

// Add analytics/tracking for tab usage (optional)
function trackTabUsage(tabName) {
    // Add your analytics tracking here if needed
    console.log(`User switched to ${tabName} tab`);
    
    // Example: Google Analytics event
    // if (typeof gtag !== 'undefined') {
    //     gtag('event', 'tab_switch', {
    //         'tab_name': tabName,
    //         'page_title': 'Script Selection'
    //     });
    // }
}

// Update showTab function to include tracking
const originalShowTab = showTab;
showTab = function(tabName) {
    originalShowTab(tabName);
    trackTabUsage(tabName);
};
// Enhanced setup text splitting functionality
function setupTextSplitting(textElement, text) {
    textElement.innerHTML = `<span class="subtitle-segment" data-segment="0">${text}</span>`;
    
    // Clear split history when setting up new text
    splitHistory = [];
    splitPositions = [];
    updateUndoButtonState();
    
    // Add click event listener for splitting
    textElement.addEventListener('click', handleTextSplit);
    
    // Add hover effects
    textElement.addEventListener('mouseenter', () => {
        if (!splittingMode) {
            textElement.classList.add('splitting-mode');
        }
    });
    
    textElement.addEventListener('mouseleave', () => {
        textElement.classList.remove('splitting-mode');
    });
    
    // Update subtitle display
    updateSubtitleDisplay();
}

// Enhanced text splitting handler with merge functionality
function handleTextSplit(event) {
    const target = event.target;
    
    // Handle split point removal
    if (target.classList.contains('split-point')) {
        event.preventDefault();
        removeSplitPoint(target);
        return;
    }
    
    // Handle segment interactions
    if (target.classList.contains('subtitle-segment')) {
        const segmentIndex = parseInt(target.dataset.segment);
        
        // Shift+Click: Merge with previous segment
        if (event.shiftKey && segmentIndex > 0) {
            event.preventDefault();
            mergeWithPrevious(segmentIndex);
            return;
        }
        
        // Double-click: Merge with next segment
        if (event.detail === 2) {
            event.preventDefault();
            mergeWithNext(segmentIndex);
            return;
        }
        
        // Ctrl+Click or Cmd+Click: Split within segment
        if (event.ctrlKey || event.metaKey) {
            event.preventDefault();
            splitWithinSegment(event, segmentIndex);
            return;
        }
    }
    
    // Default Ctrl+Click or Cmd+Click behavior for new splits
    if ((event.ctrlKey || event.metaKey) && !target.classList.contains('subtitle-segment')) {
        event.preventDefault();
        addSplitAtPosition(event);
    }
}

// Add split at clicked position (with character limit validation)
function addSplitAtPosition(event) {
    const selection = window.getSelection();
    const range = document.caretRangeFromPoint(event.clientX, event.clientY);
    
    if (!range) return;
    
    const clickPosition = getCharacterPosition(range);
    
    if (clickPosition !== -1 && clickPosition > 0 && clickPosition < previewText.length) {
        // Find the nearest word boundary
        const wordBoundaryPosition = findNearestWordBoundary(clickPosition);
        
        if (wordBoundaryPosition === -1) {
            console.log('No valid word boundary found near click position');
            showSplitError('No valid word boundary found at this position. Please click between words.');
            return;
        }
        
        // Validate character limits for both parts
        const textBeforeSplit = previewText.substring(0, wordBoundaryPosition).trim();
        const textAfterSplit = previewText.substring(wordBoundaryPosition).trim();
        
        const maxLength = window.MAX_SUBTITLE_LENGTH || 100;
        
        // Check if text before split exceeds character limit
        if (textBeforeSplit.length > maxLength) {
            console.log(`Text before split exceeds limit: ${textBeforeSplit.length} > ${maxLength}`);
            //showSplitError(`Cannot split here: Text before split point (${textBeforeSplit.length} characters) exceeds the ${maxLength} character limit. Please split earlier in the text.`);
            showSplitError(`Cannot Split Here: Exceeds The 100 Character Limit Per Slide`);
            return;
        }
        
        // Check if text after split exceeds character limit
        // if (textAfterSplit.length > maxLength) {
        //     console.log(`Text after split exceeds limit: ${textAfterSplit.length} > ${maxLength}`);
        //     showSplitError(`Cannot split here: Text after split point (${textAfterSplit.length} characters) exceeds the ${maxLength} character limit. Please split later in the text.`);
        //     return;
        // }
        
        // Check if position is not too close to existing splits
        const minDistance = 3; // Minimum characters between splits
        const tooClose = splitPositions.some(pos => Math.abs(pos - wordBoundaryPosition) < minDistance);
        
        if (!tooClose && !splitPositions.includes(wordBoundaryPosition)) {
            // Save current state to history
            saveToHistory();
            
            splitPositions.push(wordBoundaryPosition);
            splitPositions.sort((a, b) => a - b);
            
            console.log('Added split at word boundary position:', wordBoundaryPosition);
            console.log(`Split creates segments: "${textBeforeSplit.substring(0, 50)}..." (${textBeforeSplit.length} chars) | "${textAfterSplit.substring(0, 50)}..." (${textAfterSplit.length} chars)`);
            
            updateSubtitleDisplay();
            updateSubtitleCount();
            updateUndoButtonState();
            
            // Show success feedback
            showSplitSuccess(`Split created! First part: ${textBeforeSplit.length} chars, Second part: ${textAfterSplit.length} chars`);
        } else if (splitPositions.includes(wordBoundaryPosition)) {
            console.log('Split already exists at this word boundary');
            showSplitError('A split already exists at this position.');
        } else {
            console.log('Split position too close to existing split');
            showSplitError('Split position is too close to an existing split. Please choose a different location.');
        }
    }
}


// Split within a specific segment (word boundaries only)
// Split within a specific segment (with character limit validation)
function splitWithinSegment(event, segmentIndex) {
    const segments = getTextSegments();
    if (segmentIndex >= segments.length) return;
    
    // Calculate the position within the full text for this segment
    let segmentStart = 0;
    for (let i = 0; i < segmentIndex; i++) {
        segmentStart += segments[i].length;
    }
    
    // Get click position relative to the segment
    const range = document.caretRangeFromPoint(event.clientX, event.clientY);
    if (!range) return;
    
    const relativePosition = getRelativePositionInSegment(range, segmentIndex);
    if (relativePosition > 0 && relativePosition < segments[segmentIndex].length) {
        const segmentText = segments[segmentIndex];
        
        // Validate character limits for the split within this segment
        const textBeforeSplitInSegment = segmentText.substring(0, relativePosition).trim();
        const textAfterSplitInSegment = segmentText.substring(relativePosition).trim();
        
        const maxLength = window.MAX_SUBTITLE_LENGTH || 100;
        
        // Check if either part of the segment split exceeds character limit
        if (textBeforeSplitInSegment.length > maxLength) {
            console.log(`Segment text before split exceeds limit: ${textBeforeSplitInSegment.length} > ${maxLength}`);
            showSplitError(`Cannot split here: Text before split point (${textBeforeSplitInSegment.length} characters) exceeds the ${maxLength} character limit within this segment.`);
            return;
        }
        
        // if (textAfterSplitInSegment.length > maxLength) {
        //     console.log(`Segment text after split exceeds limit: ${textAfterSplitInSegment.length} > ${maxLength}`);
        //     showSplitError(`Cannot split here: Text after split point (${textAfterSplitInSegment.length} characters) exceeds the ${maxLength} character limit within this segment.`);
        //     return;
        // }
        
        const wordBoundaryPosition = findNearestWordBoundaryInSegment(
            relativePosition, 
            segmentText, 
            segmentStart
        );
        
        if (wordBoundaryPosition === -1) {
            console.log('No valid word boundary found in segment');
            showSplitError('No valid word boundary found at this position within the segment.');
            return;
        }
        
        // Save current state to history
        saveToHistory();
        
        splitPositions.push(wordBoundaryPosition);
        splitPositions.sort((a, b) => a - b);
        
        console.log('Split within segment', segmentIndex, 'at word boundary position:', wordBoundaryPosition);
        console.log(`Creates: "${textBeforeSplitInSegment}" (${textBeforeSplitInSegment.length} chars) | "${textAfterSplitInSegment}" (${textAfterSplitInSegment.length} chars)`);
        
        updateSubtitleDisplay();
        updateSubtitleCount();
        updateUndoButtonState();
        
        // Show success feedback
        showSplitSuccess(`Segment split! First part: ${textBeforeSplitInSegment.length} chars, Second part: ${textAfterSplitInSegment.length} chars`);
    }
}


// Get relative position within a segment
function getRelativePositionInSegment(range, segmentIndex) {
    const textElement = document.getElementById('preview-text');
    const segments = textElement.querySelectorAll('.subtitle-segment');
    
    if (segmentIndex >= segments.length) return -1;
    
    const segment = segments[segmentIndex];
    const textNode = segment.firstChild;
    
    if (range.startContainer === textNode) {
        return range.startOffset;
    }
    
    return -1;
}

// Merge segment with next segment
function mergeWithNext(segmentIndex) {
    const segments = getTextSegments();
    
    if (segmentIndex >= segments.length - 1) {
        console.log('Cannot merge: this is the last segment');
        return;
    }
    
    // Save current state to history
    saveToHistory();
    
    // Find the split position to remove (between current and next segment)
    let currentPos = 0;
    for (let i = 0; i < segmentIndex; i++) {
        currentPos += segments[i].length;
    }
    
    // The split position we want to remove is at currentPos + current segment length
    const splitToRemove = currentPos + segments[segmentIndex].length;
    
    // Remove this split position
    const splitIndex = splitPositions.indexOf(splitToRemove);
    if (splitIndex !== -1) {
        splitPositions.splice(splitIndex, 1);
        
        console.log('Merged segment', segmentIndex, 'with next segment');
        
        updateSubtitleDisplay();
        updateSubtitleCount();
        updateUndoButtonState();
    }
}

// Merge segment with previous segment
function mergeWithPrevious(segmentIndex) {
    if (segmentIndex <= 0) {
        console.log('Cannot merge: this is the first segment');
        return;
    }
    
    // Save current state to history
    saveToHistory();
    
    // Find the split position to remove (between previous and current segment)
    const segments = getTextSegments();
    let currentPos = 0;
    for (let i = 0; i < segmentIndex - 1; i++) {
        currentPos += segments[i].length;
    }
    
    // The split position we want to remove is at currentPos + previous segment length
    const splitToRemove = currentPos + segments[segmentIndex - 1].length;
    
    // Remove this split position
    const splitIndex = splitPositions.indexOf(splitToRemove);
    if (splitIndex !== -1) {
        splitPositions.splice(splitIndex, 1);
        
        console.log('Merged segment', segmentIndex, 'with previous segment');
        
        updateSubtitleDisplay();
        updateSubtitleCount();
        updateUndoButtonState();
    }
}

// Remove split point by clicking on it
function removeSplitPoint(splitElement) {
    const textElement = document.getElementById('preview-text');
    const splitPoints = Array.from(textElement.querySelectorAll('.split-point'));
    const splitIndex = splitPoints.indexOf(splitElement);
    
    if (splitIndex !== -1 && splitIndex < splitPositions.length) {
        // Save current state to history
        saveToHistory();
        
        splitPositions.splice(splitIndex, 1);
        
        console.log('Removed split point at index:', splitIndex);
        
        updateSubtitleDisplay();
        updateSubtitleCount();
        updateUndoButtonState();
    }
}

// Save current state to history for undo functionality
function saveToHistory() {
    const currentState = {
        splitPositions: [...splitPositions],
        timestamp: Date.now()
    };
    
    splitHistory.push(currentState);
    
    // Limit history size
    if (splitHistory.length > maxHistorySize) {
        splitHistory.shift();
    }
}

// Undo last split action
function undoLastSplit() {
    if (splitHistory.length === 0) {
        console.log('No more actions to undo');
        return;
    }
    
    const lastState = splitHistory.pop();
    splitPositions = [...lastState.splitPositions];
    
    console.log('Undid last action, restored split positions:', splitPositions);
    
    updateSubtitleDisplay();
    updateSubtitleCount();
    updateUndoButtonState();
}

// Reset all splits
function resetAllSplits() {
    if (splitPositions.length === 0) {
        console.log('No splits to reset');
        return;
    }
    
    if (confirm('Are you sure you want to reset all splits? This will create a single subtitle with all the text.')) {
        // Save current state to history
        saveToHistory();
        
        splitPositions = [];
        
        console.log('Reset all splits');
        
        updateSubtitleDisplay();
        updateSubtitleCount();
        updateUndoButtonState();
    }
}

// Update undo button state
function updateUndoButtonState() {
    const undoBtn = document.getElementById('undoSplitBtn');
    if (undoBtn) {
        undoBtn.disabled = splitHistory.length === 0;
        undoBtn.title = splitHistory.length === 0 ? 'No actions to undo' : `Undo last action (${splitHistory.length} actions available)`;
    }
}

// Enhanced subtitle display with word boundary indicators
function updateSubtitleDisplay() {
    const textElement = document.getElementById('preview-text');
    const maxLength = window.MAX_SUBTITLE_LENGTH || 80;
    
    if (splitPositions.length === 0) {
        // Single subtitle with word boundary hints
        const segment = createSubtitleSegmentWithBoundaries(previewText, 0, maxLength);
        textElement.innerHTML = segment;
    } else {
        // Multiple subtitles
        let html = '';
        let lastPosition = 0;
        
        splitPositions.forEach((position, index) => {
            const segmentText = previewText.substring(lastPosition, position);
            if (segmentText) {
                html += createSubtitleSegmentWithBoundaries(segmentText, index, maxLength);
                html += '<span class="split-point" title="Click to remove this split | Split at word boundary"></span>';
            }
            lastPosition = position;
        });
        
        // Add the final segment
        const finalSegmentText = previewText.substring(lastPosition);
        if (finalSegmentText) {
            html += createSubtitleSegmentWithBoundaries(finalSegmentText, splitPositions.length, maxLength);
        }
        
        textElement.innerHTML = html;
    }
    
    // Add word boundary visual hints
    addWordBoundaryHints(textElement);
    
    // Re-add event listeners after updating HTML
    textElement.querySelectorAll('.subtitle-segment').forEach((segment, index) => {
        // Add merge indicators on hover
        segment.addEventListener('mouseenter', () => showMergeIndicators(segment, index));
        segment.addEventListener('mouseleave', () => hideMergeIndicators(segment));
    });
}



// Create subtitle segment with word boundary awareness
function createSubtitleSegmentWithBoundaries(text, index, maxLength) {
    const exceeds = text.length > maxLength + 1;
    console.log(`Creating subtitle segment ${index + 1}: "${text.substring(0, 50)}..." (${text.length} chars)`);
    const className = exceeds ? 'subtitle-segment exceeds-limit' : 'subtitle-segment';
    
    let title = `Subtitle ${index + 1}: ${text.length}/${maxLength} characters\n`;
    title += `• Double-click to merge with next\n`;
    title += `• Shift+click to merge with previous\n`;
    title += `• Ctrl+click to split at word boundary within this segment`;
    
    if (exceeds) {
        title += `\n⚠️ Exceeds character limit! Try splitting at word boundaries.`;
    }
    
    return `<div><span class="${className}" data-segment="${index}" data-segment-number="${index + 1}" title="${title}">${text}</span></div>`;
}

// Add visual hints for word boundaries
function addWordBoundaryHints(textElement) {
    // Add CSS class to show word boundary cursor
    textElement.classList.add('word-boundary-mode');
    
    // Optional: Add subtle visual indicators for potential split points
    // This is subtle and only shows on hover
}

// Enhanced subtitle segment creation with numbering
function createSubtitleSegment(text, index, maxLength) {
    const exceeds = text.length > maxLength + 1;
    const className = exceeds ? 'subtitle-segment exceeds-limit' : 'subtitle-segment';
    
    let title = `Subtitle ${index + 1}: ${text.length}/${maxLength} characters\n`;
    title += `• Double-click to merge with next\n`;
    title += `• Shift+click to merge with previous\n`;
    title += `• Ctrl+click to split within this segment`;
    
    if (exceeds) {
        title += `\n⚠️ Exceeds character limit!`;
    }
    
    return `<div><span class="${className}" data-segment="${index}" data-segment-number="${index + 1}" title="${title}">${text}</span></div>`;
}

// Show merge indicators
function showMergeIndicators(segment, index) {
    const segments = document.querySelectorAll('.subtitle-segment');
    
    // Show previous merge indicator
    if (index > 0) {
        segment.classList.add('mergeable-prev');
    }
    
    // Show next merge indicator
    if (index < segments.length - 1) {
        segment.classList.add('mergeable-next');
    }
}

// Hide merge indicators
function hideMergeIndicators(segment) {
    segment.classList.remove('mergeable-prev', 'mergeable-next', 'merge-preview');
}
// Get character position from range
function getCharacterPosition(range) {
    const textElement = document.getElementById('preview-text');
    const preElement = range.startContainer;
    
    if (preElement.nodeType === Node.TEXT_NODE) {
        // Find the position within the full text
        let position = 0;
        const walker = document.createTreeWalker(
            textElement,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );
        
        let node;
        while (node = walker.nextNode()) {
            if (node === preElement) {
                return position + range.startOffset;
            }
            position += node.textContent.length;
        }
    }
    
    return -1;
}

// Update subtitle display with segments and split points
function updateSubtitleDisplay() {
    const textElement = document.getElementById('preview-text');
    const maxLength = window.MAX_SUBTITLE_LENGTH || 80;
    
    if (splitPositions.length === 0) {
        // Single subtitle
        const segment = createSubtitleSegment(previewText, 0, maxLength);
        textElement.innerHTML = segment;
    } else {
        // Multiple subtitles
        let html = '';
        let lastPosition = 0;
        
        splitPositions.forEach((position, index) => {
            const segmentText = previewText.substring(lastPosition, position);
            if (segmentText) {
                html += createSubtitleSegment(segmentText, index, maxLength);
                html += '';
            }
            lastPosition = position;
        });
        
        // Add the final segment
        const finalSegmentText = previewText.substring(lastPosition);
        if (finalSegmentText) {
            html += createSubtitleSegment(finalSegmentText, splitPositions.length, maxLength);
        }
        
        textElement.innerHTML = html;
    }
    
    // Add click handlers to segments for removal
    textElement.querySelectorAll('.subtitle-segment').forEach(segment => {
        segment.addEventListener('dblclick', (e) => {
            e.preventDefault();
            removeSegmentSplit(segment);
        });
    });
}

// Create a subtitle segment with appropriate styling
function createSubtitleSegment(text, index, maxLength) {
    const exceeds = text.length > maxLength + 1;
    const className = exceeds ? 'subtitle-segment exceeds-limit' : 'subtitle-segment';
    const title = exceeds ? `Exceeds limit: ${text.length}/${maxLength} characters.` : 
                           `Subtitle ${index + 1}: ${text.length}/${maxLength} characters`;
    
    return `<div><span class="${className}" data-segment="${index}" title="${title}">${text}</span><span class="split-point"></span></div>`;
}

// Remove a split point by double-clicking a segment
function removeSegmentSplit(segmentElement) {
    const segmentIndex = parseInt(segmentElement.dataset.segment);
    
    if (segmentIndex > 0 && splitPositions.length > 0) {
        // Remove the split position before this segment
        splitPositions.splice(segmentIndex - 1, 1);
        
        console.log('Removed split, remaining positions:', splitPositions);
        
        updateSubtitleDisplay();
        updateSubtitleCount();
    }
}

// Update subtitle count display
function updateSubtitleCount() {
    const subtitleCountElement = document.getElementById('preview-subtitle-count');
    const subtitleCount = splitPositions.length + 1;
    const maxLength = window.MAX_SUBTITLE_LENGTH || 80;
    
    // Check how many subtitles exceed the limit
    const segments = getTextSegments();
    const exceedsCount = segments.filter(segment => segment.length > maxLength + 1).length;
    
    let countText = `${subtitleCount} subtitle${subtitleCount === 1 ? '' : 's'}`;
    
    if (exceedsCount > 0) {
        countText += ` (${exceedsCount} exceed${exceedsCount === 1 ? 's' : ''} limit)`;
        subtitleCountElement.className = 'subtitle-count subtitle-count-warning';
    } else {
        subtitleCountElement.className = 'subtitle-count';
    }
    
    subtitleCountElement.textContent = countText;
    
    // Update load button state
    updateLoadButtonState(subtitleCount, exceedsCount);
}

// Get text segments based on current split positions
function getTextSegments() {
    if (splitPositions.length === 0) {
        return [previewText];
    }
    
    const segments = [];
    let lastPosition = 0;
    
    splitPositions.forEach(position => {
        segments.push(previewText.substring(lastPosition, position));
        lastPosition = position;
    });
    
    segments.push(previewText.substring(lastPosition));
    
    return segments.filter(segment => segment.trim().length > 0);
}

// Update load button state based on subtitle validation
function updateLoadButtonState(subtitleCount, exceedsCount) {
    const loadButton = document.getElementById('historyLoadButton');
    
    if (!loadButton) return;
    
    let canLoad = true;
    let disableReason = '';
    
    // Check free plan restrictions
    if (typeof isFreePlan !== 'undefined' && isFreePlan && subtitleCount > 10) {
        canLoad = false;
        disableReason = `Free plan limited to 10 subtitles (you have ${subtitleCount})`;
    }
    
    // Check character limit violations
    if (exceedsCount > 0) {
        canLoad = false;
        disableReason = `${exceedsCount} subtitle${exceedsCount === 1 ? '' : 's'} exceed character limit`;
    }
    
    loadButton.disabled = !canLoad;
    loadButton.title = canLoad ? 'Load selected voiceover' : disableReason;
    
    if (!canLoad) {
        loadButton.style.opacity = '0.5';
        loadButton.style.cursor = 'not-allowed';
    } else {
        loadButton.style.opacity = '1';
        loadButton.style.cursor = 'pointer';
    }
}


// Function to delete all existing clips from server and local state
function deleteAllClips() {
    return new Promise((resolve, reject) => {
        // Get video ID from the URL
        const path = window.location.pathname;
        const videoId = path.split('/')[2];
        
        // Get CSRF token from cookie
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        
        const csrftoken = getCookie('csrftoken');
        
        // Prepare data for the request
        const data = {
            video_id: videoId
        };
        
        console.log('Deleting all clips for video:', videoId);
        console.log('Current slides to be deleted:', slides.map(s => ({ id: s.id, text: s.text.substring(0, 30) + '...' })));
        
        // Send AJAX request to delete all clips
        fetch('/delete-all-clips/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken,
            },
            body: JSON.stringify(data),
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log('All clips deleted successfully:', data);
                console.log(`Deleted ${data.deleted_count} clips and ${data.subclips_deleted_count} subclips`);
                resolve(data);
            } else {
                console.error('Error deleting clips:', data.error);
                reject(new Error(data.error || 'Failed to delete clips'));
            }
        })
        .catch(error => {
            console.error('Network error deleting clips:', error);
            reject(error);
        });
    });
}


// Find the nearest word boundary to a given position
function findNearestWordBoundary(position) {
    // Word boundary characters: space, punctuation, etc.
    const wordBoundaryRegex = /[\s\.,!?;:\-\(\)\[\]{}""'']/;
    
    // Look for word boundaries before and after the position
    let beforeBoundary = -1;
    let afterBoundary = -1;
    
    // Search backwards for word boundary
    for (let i = position - 1; i >= 0; i--) {
        if (wordBoundaryRegex.test(previewText[i])) {
            beforeBoundary = i + 1; // Position after the boundary character
            break;
        }
    }
    
    // Search forwards for word boundary
    for (let i = position; i < previewText.length; i++) {
        if (wordBoundaryRegex.test(previewText[i])) {
            afterBoundary = i;
            break;
        }
    }
    
    // Choose the closest boundary
    if (beforeBoundary === -1 && afterBoundary === -1) {
        return -1; // No word boundary found
    } else if (beforeBoundary === -1) {
        return afterBoundary;
    } else if (afterBoundary === -1) {
        return beforeBoundary;
    } else {
        // Choose the closer one
        const distanceBefore = position - beforeBoundary;
        const distanceAfter = afterBoundary - position;
        return distanceBefore <= distanceAfter ? beforeBoundary : afterBoundary;
    }
}

// Find word boundary within a specific segment
function findNearestWordBoundaryInSegment(relativePosition, segmentText, segmentStart) {
    const wordBoundaryRegex = /[\s\.,!?;:\-\(\)\[\]{}""'']/;
    
    let beforeBoundary = -1;
    let afterBoundary = -1;
    
    // Search backwards within segment
    for (let i = relativePosition - 1; i >= 0; i--) {
        if (wordBoundaryRegex.test(segmentText[i])) {
            beforeBoundary = segmentStart + i + 1;
            break;
        }
    }
    
    // Search forwards within segment
    for (let i = relativePosition; i < segmentText.length; i++) {
        if (wordBoundaryRegex.test(segmentText[i])) {
            afterBoundary = segmentStart + i;
            break;
        }
    }
    
    // Choose the closest boundary
    if (beforeBoundary === -1 && afterBoundary === -1) {
        return -1;
    } else if (beforeBoundary === -1) {
        return afterBoundary;
    } else if (afterBoundary === -1) {
        return beforeBoundary;
    } else {
        const absoluteClickPos = segmentStart + relativePosition;
        const distanceBefore = absoluteClickPos - beforeBoundary;
        const distanceAfter = afterBoundary - absoluteClickPos;
        return distanceBefore <= distanceAfter ? beforeBoundary : afterBoundary;
    }
}

// Check if a position is at a valid word boundary
function isValidWordBoundary(position) {
    if (position <= 0 || position >= previewText.length) {
        return false;
    }
    
    const wordBoundaryRegex = /[\s\.,!?;:\-\(\)\[\]{}""'']/;
    
    // Check if the character before the position is a word boundary
    // and the character at the position starts a new word
    const charBefore = previewText[position - 1];
    const charAt = previewText[position];
    
    return wordBoundaryRegex.test(charBefore) && !wordBoundaryRegex.test(charAt);
}

// Get all possible word boundary positions in the text
function getAllWordBoundaries() {
    const boundaries = [];
    const wordBoundaryRegex = /[\s\.,!?;:\-\(\)\[\]{}""'']/;
    
    for (let i = 1; i < previewText.length; i++) {
        if (wordBoundaryRegex.test(previewText[i - 1]) && !wordBoundaryRegex.test(previewText[i])) {
            boundaries.push(i);
        }
    }
    
    return boundaries;
}


// Validate that all splits are at word boundaries
function validateWordBoundaries() {
    const invalidSplits = splitPositions.filter(pos => !isValidWordBoundary(pos));
    
    if (invalidSplits.length > 0) {
        console.warn('Found invalid word boundary splits:', invalidSplits);
        
        // Auto-correct invalid splits
        splitPositions = splitPositions
            .map(pos => isValidWordBoundary(pos) ? pos : findNearestWordBoundary(pos))
            .filter(pos => pos !== -1)
            .filter((pos, index, arr) => arr.indexOf(pos) === index) // Remove duplicates
            .sort((a, b) => a - b);
        
        console.log('Corrected split positions:', splitPositions);
        
        updateSubtitleDisplay();
        updateSubtitleCount();
    }
    
    return invalidSplits.length === 0;
}

// Clean and normalize text before preview
function cleanPreviewText(rawText) {
    if (!rawText) return '';
    
    // Step 1: Remove extra whitespace and normalize line breaks
    let cleanedText = rawText
        // Replace all types of line breaks with standard newlines
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n')
        // Replace multiple consecutive newlines with single newlines
        .replace(/\n{2,}/g, '\n')
        // Remove leading and trailing whitespace from each line
        .split('\n')
        .map(line => line.trim())
        // Remove completely empty lines
        .filter(line => line.length > 0)
        // Join back with spaces to create one paragraph
        .join(' ');
    
    // Step 2: Clean up spacing issues
    cleanedText = cleanedText
        // Replace multiple consecutive spaces with single space
        .replace(/\s{2,}/g, ' ')
        // Remove spaces before punctuation
        .replace(/\s+([,.!?;:])/g, '$1')
        // Ensure single space after punctuation
        .replace(/([,.!?;:])\s*/g, '$1 ')
        // Remove extra spaces around quotes
        .replace(/\s*([""''"])\s*/g, '$1')
        // Clean up parentheses spacing
        .replace(/\s*\(\s*/g, ' (')
        .replace(/\s*\)\s*/g, ') ')
        // Clean up hyphen spacing
        .replace(/\s*-\s*/g, ' - ')
        // Final trim
        .trim();
    
    // Step 3: Handle special cases
    cleanedText = cleanedText
        // Fix spacing after sentence-ending punctuation
        .replace(/([.!?])\s+/g, '$1 ')
        // Remove space at the beginning
        .replace(/^\s+/, '')
        // Remove space at the end
        .replace(/\s+$/, '');
    
    // Step 4: Validate minimum length
    if (cleanedText.length < 10) {
        console.warn('Cleaned text is very short:', cleanedText);
    }
    
    console.log('Text cleaning stats:');
    console.log('Original length:', rawText.length);
    console.log('Cleaned length:', cleanedText.length);
    console.log('Original (first 100 chars):', rawText.substring(0, 100));
    console.log('Cleaned (first 100 chars):', cleanedText.substring(0, 100));
    
    return cleanedText;
}


// Enhanced function to fetch saved history with HTML
async function fetchSavedHistory(historyId) {
    try {
        // Get video ID from URL
        const path = window.location.pathname;
        const videoId = path.split('/')[2];
        
        // Get CSRF token
        const csrftoken = getCookie('csrftoken');
        
        console.log('Fetching saved history for ID:', historyId);
        
        const response = await fetch(`/videos/${videoId}/saved-history/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': csrftoken,
                'Content-Type': 'application/json'
            }
        });
        
        const data = await response.json();
        console.log('Saved history response:', data);
        
        if (data.history && data.history.length > 0) {
            const historyItem = data.history[0];
            
            // ADD THIS: Check if we have saved HTML and restore it
            if (data.saved_preview_html) {
                console.log('Found saved preview HTML, attempting to restore...');
                
                // Set up the preview with saved HTML after a short delay
                setTimeout(() => {
                    restoreSavedPreview(
                        data.saved_preview_html, 
                        data.saved_split_positions,
                        data.saved_preview_text
                    );
                }, 200);
            }
            
            return historyItem; // Return the fetched history item
        } else {
            throw new Error('No saved history found');
        }
    } catch (error) {
        console.error('Error fetching saved history:', error);
        throw error;
    }
}



// Helper function to handle history item selection (extracted for reuse)
async function selectHistoryItemAtIndex(index, isAutoSelected = false) {
    const selectElement = document.getElementById('voiceover-history-select');
    
    // Set the dropdown value
    selectElement.value = index.toString();
    
    // Trigger the selection event
    const event = new Event('change', { bubbles: true });
    selectElement.dispatchEvent(event);
    
    console.log(`${isAutoSelected ? 'Auto-selected' : 'Selected'} history item at index ${index}`);
    
    // Add visual indication if auto-selected
    if (isAutoSelected) {
        setTimeout(() => {
            const previewElement = document.getElementById('selected-history-preview');
        
            
            // Scroll to the preview
            previewElement?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 100);
    }
}


// Function to show split error messages
function showSplitError(message) {
    const errorDiv = document.createElement('div');
    errorDiv.className = 'split-feedback split-error';
    errorDiv.textContent = message;
    errorDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #ffebee;
        color: #c62828;
        padding: 12px 16px;
        border-radius: 6px;
        border-left: 4px solid #c62828;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        z-index: 10000;
        max-width: 350px;
        font-size: 14px;
        line-height: 1.4;
    `;
    
    document.body.appendChild(errorDiv);
    
    setTimeout(() => {
        errorDiv.remove();
    }, 4000);
}

// Function to show split success messages
function showSplitSuccess(message) {
    const successDiv = document.createElement('div');
    successDiv.className = 'split-feedback split-success';
    successDiv.textContent = message;
    successDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #e8f5e8;
        color: #2e7d32;
        padding: 12px 16px;
        border-radius: 6px;
        border-left: 4px solid #4caf50;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        z-index: 10000;
        max-width: 350px;
        font-size: 14px;
        line-height: 1.4;
    `;
    
    document.body.appendChild(successDiv);
    
    setTimeout(() => {
        successDiv.remove();
    }, 3000);
}
// Enhanced history split file handler with real-time preview
function handleHistorySplitFileChange(event) {
    const file = event.target.files[0];
    historySplitFile = file;
    
    const statusDiv = document.getElementById('splitFileStatus');
    const statusIcon = document.getElementById('statusIcon');
    const statusTitle = document.getElementById('statusTitle');
    const statusSubtitle = document.getElementById('statusSubtitle');
    
    // Hide any existing preview
    hideCustomSplitPreview();
    
    if (!file) {
        // File was cleared
        historySplitFileName = "No file chosen";
        customSplitLines = null;
        statusDiv.style.display = 'none';
        return;
    }
    
    // Show loading status
    showFileStatus('loading', 'Processing file...', 'Reading and validating content');
    
    if (!file.name.toLowerCase().endsWith('.txt')) {
        showFileStatus('error', 'Invalid file type', 'Please select a .txt file');
        event.target.value = "";
        historySplitFile = null;
        historySplitFileName = "No file chosen";
        customSplitLines = null;
        return;
    }
    
    historySplitFileName = file.name;
    
    // Read and validate the file content
    const reader = new FileReader();
    reader.onload = function(e) {
        const content = e.target.result;
        const lines = content.split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0);
        
        if (lines.length === 0) {
            showFileStatus('error', 'File is empty', 'Please provide a file with text content');
            event.target.value = "";
            historySplitFile = null;
            historySplitFileName = "No file chosen";
            customSplitLines = null;
            return;
        }
        
        // Check character limits
        const maxLength = window.MAX_SUBTITLE_LENGTH || 100;
        const exceededLines = lines.filter(line => line.length > maxLength);
        
        if (exceededLines.length > 0) {
            showFileStatus('error', 'Character limit exceeded', `${exceededLines.length} line(s) exceed ${maxLength} characters`);
            event.target.value = "";
            historySplitFile = null;
            historySplitFileName = "No file chosen";
            customSplitLines = null;
            return;
        }
        
        // Check if a voiceover is selected for comparison
        if (!selectedHistoryItem) {
            showFileStatus('warning', 'Select voiceover first', 'Please select a voiceover to validate against');
            customSplitLines = lines; // Store for later validation
            return;
        }
        
        // Validate against selected voiceover
        validateAndPreviewSplit(lines);
    };
    
    reader.onerror = function() {
        showFileStatus('error', 'File read error', 'Could not read the selected file');
        event.target.value = "";
        historySplitFile = null;
        historySplitFileName = "No file chosen";
        customSplitLines = null;
    };
    
    reader.readAsText(file);
}

// Function to show file status
function showFileStatus(type, title, subtitle) {
    const statusDiv = document.getElementById('splitFileStatus');
    const statusIcon = document.getElementById('statusIcon');
    const statusTitle = document.getElementById('statusTitle');
    const statusSubtitle = document.getElementById('statusSubtitle');
    
    statusDiv.style.display = 'block';
    statusTitle.textContent = title;
    statusSubtitle.textContent = subtitle;
    
    switch(type) {
        case 'loading':
            statusDiv.style.background = 'linear-gradient(135deg, #fef3c7 0%, #fde68a 100%)';
            statusDiv.style.border = '1px solid #f59e0b';
            statusIcon.style.background = '#f59e0b';
            statusIcon.style.color = 'white';
            statusIcon.textContent = '⟳';
            statusTitle.style.color = '#92400e';
            statusSubtitle.style.color = '#92400e';
            break;
        case 'success':
            statusDiv.style.background = 'linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%)';
            statusDiv.style.border = '1px solid #10b981';
            statusIcon.style.background = '#10b981';
            statusIcon.style.color = 'white';
            statusIcon.textContent = '✓';
            statusTitle.style.color = '#065f46';
            statusSubtitle.style.color = '#065f46';
            break;
        case 'error':
            statusDiv.style.background = 'linear-gradient(135deg, #fee2e2 0%, #fecaca 100%)';
            statusDiv.style.border = '1px solid #ef4444';
            statusIcon.style.background = '#ef4444';
            statusIcon.style.color = 'white';
            statusIcon.textContent = '✕';
            statusTitle.style.color = '#991b1b';
            statusSubtitle.style.color = '#991b1b';
            break;
        case 'warning':
            statusDiv.style.background = 'linear-gradient(135deg, #fef3c7 0%, #fde68a 100%)';
            statusDiv.style.border = '1px solid #f59e0b';
            statusIcon.style.background = '#f59e0b';
            statusIcon.style.color = 'white';
            statusIcon.textContent = '⚠';
            statusTitle.style.color = '#92400e';
            statusSubtitle.style.color = '#92400e';
            break;
    }
}

// Function to validate split against voiceover and show preview
function validateAndPreviewSplit(lines) {
    if (!selectedHistoryItem) {
        showFileStatus('warning', 'Select voiceover first', 'Please select a voiceover to validate against');
        return;
    }
    
    // Get voiceover text
    const voiceoverText = cleanPreviewText(selectedHistoryItem.text || 
                                          (selectedHistoryItem.dialogue?.[0]?.text) || '');
    const uploadedText = lines.join(' ').replace(/\s+/g, ' ').trim();
    const normalizedVoiceoverText = voiceoverText.replace(/\s+/g, ' ').trim();
    
    // Calculate similarity
    const similarity = calculateTextSimilarity(normalizedVoiceoverText, uploadedText);
    console.log('Text validation - Similarity:', similarity);


    if (similarity < 0.95) {
        showFileStatus('error', 'Text mismatch detected', `Content similarity: ${(similarity * 100).toFixed(1)}% (need 95%+)`);
        customSplitLines = null;
        return;
    }
    
    // Validation successful - store lines and show preview
    customSplitLines = lines;
    showFileStatus('success', 'File validated successfully', `${lines.length} subtitle segments ready`);
    
    // Show custom split preview
    showCustomSplitPreview(lines);
}

// Function to show custom split preview
function showCustomSplitPreview(lines) {
    const previewElement = document.getElementById('preview-text');
    if (!previewElement) return;
    
    // Create segments display
    const maxLength = window.MAX_SUBTITLE_LENGTH || 100;
    let html = '';
    
    lines.forEach((line, index) => {
        const exceeds = line.length > maxLength;
        const className = exceeds ? 'custom-split-segment exceeds-limit' : 'custom-split-segment';
        
        html += `<div class="${className}" data-segment="${index}" data-length="${line.length}">
            <span class="segment-number">${index + 1}</span>
            <span class="segment-text">${line}</span>
            <span class="segment-length">${line.length}/${maxLength}</span>
        </div>`;
    });
    
    // Replace preview content temporarily
    previewElement.innerHTML = `

            <div class="custom-split-segments">
                ${html}
            </div>
    `;
    
    // Update subtitle count
    updateSubtitleCountForCustomSplit(lines);
}

// Function to hide custom split preview
function hideCustomSplitPreview() {
    const previewElement = document.getElementById('preview-text');
    if (!previewElement || !previewElement.querySelector('.custom-split-preview')) {
        return;
    }
    
    // Restore original preview if available
    if (currentHistoryItem) {
        setupTextSplitting(previewElement, previewText);
        updateSubtitleCount();
    }
}

// Function to update subtitle count for custom split
function updateSubtitleCountForCustomSplit(lines) {
    const subtitleCountElement = document.getElementById('preview-subtitle-count');
    const maxLength = window.MAX_SUBTITLE_LENGTH || 80;
    
    const exceedsCount = lines.filter(line => line.length > maxLength).length;
    
    let countText = `${lines.length} subtitle${lines.length === 1 ? '' : 's'} (custom)`;
    
    if (exceedsCount > 0) {
        countText += ` (${exceedsCount} exceed${exceedsCount === 1 ? 's' : ''} limit)`;
        subtitleCountElement.className = 'subtitle-count subtitle-count-warning';
    } else {
        subtitleCountElement.className = 'subtitle-count';
    }
    
    subtitleCountElement.textContent = countText;
    
    // Update load button state
    updateLoadButtonStateForCustomSplit(lines.length, exceedsCount);
}

// Function to update load button for custom split
function updateLoadButtonStateForCustomSplit(subtitleCount, exceedsCount) {
    const loadButton = document.getElementById('historyLoadButton');
    
    if (!loadButton) return;
    
    let canLoad = true;
    let disableReason = '';
    
    // Check free plan restrictions
    if (typeof isFreePlan !== 'undefined' && isFreePlan && subtitleCount > 10) {
        canLoad = false;
        disableReason = `Free plan limited to 10 subtitles (file has ${subtitleCount})`;
    }
    
    // Check character limit violations
    if (exceedsCount > 0) {
        canLoad = false;
        disableReason = `${exceedsCount} subtitle${exceedsCount === 1 ? '' : 's'} exceed character limit`;
    }
    
    loadButton.disabled = !canLoad;
    loadButton.title = canLoad ? 'Load voiceover with custom splitting' : disableReason;
    
    if (!canLoad) {
        loadButton.style.opacity = '0.5';
        loadButton.style.cursor = 'not-allowed';
    } else {
        loadButton.style.opacity = '1';
        loadButton.style.cursor = 'pointer';
    }
}
// Helper function to calculate text similarity
function calculateTextSimilarity(text1, text2) {
    // Simple similarity calculation based on character matching
    const len1 = text1.length;
    const len2 = text2.length;
    const maxLen = Math.max(len1, len2);
    
    if (maxLen === 0) return 1; // Both empty
    
    // Count matching characters
    let matches = 0;
    const minLen = Math.min(len1, len2);
    
    for (let i = 0; i < minLen; i++) {
        if (text1[i].toLowerCase() === text2[i].toLowerCase()) {
            matches++;
        }
    }
    
    // Account for length difference
    const similarity = matches / maxLen;
    
    // Additional check for word-level similarity
    const words1 = text1.toLowerCase().split(/\s+/).filter(w => w.length > 0);
    const words2 = text2.toLowerCase().split(/\s+/).filter(w => w.length > 0);
    
    const commonWords = words1.filter(word => words2.includes(word));
    const totalWords = Math.max(words1.length, words2.length);
    const wordSimilarity = totalWords > 0 ? commonWords.length / totalWords : 0;
    
    // Return weighted average of character and word similarity
    return (similarity * 0.7 + wordSimilarity * 0.3);
}
    </script>
<!-- WhatsApp Chat Button -->
<a href="https://wa.me/447770218787?text=Hi%2C%20I%20need%20support" 
   class="whatsapp-chat-button" 
   target="_blank" 
   title="Chat with us on WhatsApp">
   <img src="https://upload.wikimedia.org/wikipedia/commons/6/6b/WhatsApp.svg" alt="Chat on WhatsApp" width="60">
</a>

<style>
.whatsapp-chat-button {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #25D366;
  border-radius: 50%;
  padding: 0.5em;
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  transition: transform 0.2s ease-in-out;
}

/* Icon image with responsive scaling */
.whatsapp-chat-button img {
  width: clamp(30px, 5vw, 48px);  /* Auto-scale based on screen width */
  height: clamp(30px, 5vw, 48px);
  max-width: 100%;
  max-height: 100%;
}

.whatsapp-chat-button:hover {
  transform: scale(1.1);
}
</style>


</body>

</html>